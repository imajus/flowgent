{
  "name": "Agentic - Search FLIX templates",
  "nodes": [
    {
      "parameters": {
        "url": "https://flix-agentic.majus.app/v1/templates",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        220,
        0
      ],
      "id": "ad095836-a0e5-4753-ac9f-a8a814f1c795",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "07d1df47-37de-44ea-849d-d8e68df02f3b",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "29dd0605-d546-493b-920e-c8f7be084ac1",
              "name": "title",
              "value": "={{ $json.data.messages.title.i18n['en-US'] }}",
              "type": "string"
            },
            {
              "id": "d5f08202-f3c5-4fe5-8969-ccfefc33573c",
              "name": "description",
              "value": "={{ $json.data.messages.description.i18n['en-US'] }}",
              "type": "string"
            },
            {
              "id": "fb83d295-3e01-493a-b1b2-2827d8189470",
              "name": "arguments",
              "value": "={{ Object.entries($json.data.arguments).map(([name, data]) => `${name}: ${data.type} - ${data.messages.title.i18n['en-US']}`) }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        440,
        0
      ],
      "id": "a2d8e3d9-a20a-40c6-9f20-af23be3cebb3",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "7bd917cd-d344-4bb6-8076-aac66f183025",
      "name": "Workflow Input Trigger"
    }
  ],
  "pinData": {
    "HTTP Request": [
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "290b6b6222b2a77b16db896a80ddf29ebd1fa3038c9e6625a933fa213fce51fa",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Transfer Tokens"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Transfer tokens from one account to another"
                }
              }
            },
            "cadence": "import FungibleToken from 0xFUNGIBLETOKENADDRESS\ntransaction(amount: UFix64, to: Address) {\nlet vault: @FungibleToken.Vault\nprepare(signer: AuthAccount) {\nself.vault <- signer\n.borrow<&{FungibleToken.Provider}>(from: /storage/flowTokenVault)!\n.withdraw(amount: amount)\n}\nexecute {\ngetAccount(to)\n.getCapability(/public/flowTokenReceiver)!\n.borrow<&{FungibleToken.Receiver}>()!\n.deposit(from: <-self.vault)\n}\n}",
            "dependencies": {
              "0xFUNGIBLETOKENADDRESS": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "contract": "FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 34166296
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "contract": "FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 74776482
                  }
                }
              }
            },
            "arguments": {
              "amount": {
                "index": 0,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of FLOW tokens to send"
                    }
                  }
                },
                "balance": ""
              },
              "to": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Flow account the tokens will go to"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "38d0cca4b74c4e88213df636b4cfc2eb6e86fd8b2b84579d3b9bffab3e0b1fcb",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Close Stake"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Closes a stake held in a Staking Collection."
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n// Closes out a staking object in the staking collection\n// This does not remove the record from the identity table,\n// but it does mean that the account that closes it cannot ever access it again\ntransaction(nodeID: String, delegatorID: UInt32?) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.closeStake(nodeID: nodeID, delegatorID: delegatorID)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74308355
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 33862742
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Delegator ID"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "83d205597ed6a447c8687a4b4144872c65f0b53fb31b65d51a3c1c904a6ff417",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Create Machine Account"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Creates a Machine Account for node held in Staking Collection"
                }
              }
            },
            "cadence": "import Crypto\nimport FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Creates a machine account for a node that is already in the staking collection\n/// and adds public keys to the new account\ntransaction(nodeID: String, publicKeys: [Crypto.KeyListEntry]) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        if let machineAccount = self.stakingCollectionRef.createMachineAccountForExistingNode(nodeID: nodeID, payer: account) {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        } else {\n            panic(\"Could not create a machine account for the node\")\n        }\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74308589
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 33862897
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Node ID"
                    }
                  }
                },
                "balance": ""
              },
              "publicKeys": {
                "index": 1,
                "type": "[Crypto.KeyListEntry]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Public Keys for the Machine Account (comma separated)"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "b8a3ed26c222ed67016a28021d8fee5603b948533cbc992b3c90f71a61b2b312",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Register Delegator"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Register a delegator held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Registers a delegator in the staking collection resource\n/// for the specified nodeID and the amount of tokens to commit\ntransaction(id: String, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.registerDelegator(nodeID: id, amount: amount)      \n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74559520
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34026728
                  }
                }
              }
            },
            "arguments": {
              "id": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID to delegate to"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 1,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of FLOW tokens to delegate"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "6d1ea6bf8bda73132afd038e0c9aabca8abeb84ac11259cbefa36b9337f2d19e",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Register Node"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Register a node held in a Staking Collection"
                }
              }
            },
            "cadence": "import Crypto\nimport FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Registers a delegator in the staking collection resource\n/// for the specified node information and the amount of tokens to commit\ntransaction(id: String,\n            role: UInt8,\n            networkingAddress: String,\n            networkingKey: String,\n            stakingKey: String,\n            amount: UFix64,\n            publicKeys: [Crypto.KeyListEntry]?) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        if let machineAccount = self.stakingCollectionRef.registerNode(\n            id: id,\n            role: role,\n            networkingAddress: networkingAddress,\n            networkingKey: networkingKey,\n            stakingKey: stakingKey,\n            amount: amount,\n            payer: account) \n        {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys! {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        }\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74559839
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34026928
                  }
                }
              }
            },
            "arguments": {
              "id": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID"
                    }
                  }
                },
                "balance": ""
              },
              "role": {
                "index": 1,
                "type": "UInt8",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node role to register"
                    }
                  }
                },
                "balance": ""
              },
              "networkingAddress": {
                "index": 2,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The networking address"
                    }
                  }
                },
                "balance": ""
              },
              "networkingKey": {
                "index": 3,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The networking key"
                    }
                  }
                },
                "balance": ""
              },
              "stakingKey": {
                "index": 4,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The staking key"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 5,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of FLOW tokens to stake"
                    }
                  }
                },
                "balance": ""
              },
              "publicKeys": {
                "index": 6,
                "type": "[Crypto.KeyListEntry]?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Public Keys for the Machine Account (comma separated). Only required when registering Consensus or Collection nodes"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7ccd27aff8b42d4d61586f79eb5e11d55d01afdef384c9a7246bb1e1d385beb0",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Request Unstaking"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Requests unstaking for a stake held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Requests unstaking for the specified node or delegator in the staking collection\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.requestUnstaking(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74560125
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34027115
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The delegator ID"
                    }
                  }
                },
                "balance": ""
              },
              "UFix64": {
                "index": 2,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount to request to be unstaked"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "dfb30fb76518ae901dc18993d8a00a8329a5d4b36dfd4bd357245457aa47eea8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Setup Staking Collection"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Sets up a Staking Collection for an account"
                }
              }
            },
            "cadence": "import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport FlowToken from 0xFLOWTOKENADDRESS\nimport FlowIDTableStaking from 0xIDENTITYTABLEADDRESS\nimport LockedTokens from 0xLOCKEDTOKENADDRESS\nimport FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// This transaction sets up an account to use a staking collection\n/// It will work regardless of whether they have a regular account, a two-account locked tokens setup,\n/// or staking objects stored in the unlocked account\ntransaction {\n    prepare(signer: AuthAccount) {\n        // If there isn't already a staking collection\n        if signer.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath) == nil {\n            // Create private capabilities for the token holder and unlocked vault\n            let lockedHolder = signer.link<&LockedTokens.TokenHolder>(/private/flowTokenHolder, target: LockedTokens.TokenHolderStoragePath)!\n            let flowToken = signer.link<&FlowToken.Vault>(/private/flowTokenVault, target: /storage/flowTokenVault)!\n            \n            // Create a new Staking Collection and put it in storage\n            if lockedHolder.check() {\n                signer.save(<-FlowStakingCollection.createStakingCollection(unlockedVault: flowToken, tokenHolder: lockedHolder), to: FlowStakingCollection.StakingCollectionStoragePath)\n            } else {\n                signer.save(<-FlowStakingCollection.createStakingCollection(unlockedVault: flowToken, tokenHolder: nil), to: FlowStakingCollection.StakingCollectionStoragePath)\n            }\n            // Create a public link to the staking collection\n            signer.link<&FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}>(\n                FlowStakingCollection.StakingCollectionPublicPath,\n                target: FlowStakingCollection.StakingCollectionStoragePath\n            )\n        }\n        // borrow a reference to the staking collection\n        let collectionRef = signer.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow staking collection reference\")\n        // If there is a node staker object in the account, put it in the staking collection\n        if signer.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath) != nil {\n            let node <- signer.load<@FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)!\n            collectionRef.addNodeObject(<-node, machineAccountInfo: nil)\n        }\n        // If there is a delegator object in the account, put it in the staking collection\n        if signer.borrow<&FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath) != nil {\n            let delegator <- signer.load<@FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)!\n            collectionRef.addDelegatorObject(<-delegator)\n        }\n    }\n}\n",
            "dependencies": {
              "0xFUNGIBLETOKENADDRESS": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "contract": "FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 34157509
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "contract": "FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 74762620
                  }
                }
              },
              "0xFLOWTOKENADDRESS": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "contract": "FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 34157509
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "contract": "FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 74762620
                  }
                }
              },
              "0xIDENTITYTABLEADDRESS": {
                "FlowIDTableStaking": {
                  "testnet": {
                    "address": "0x9eca2b38b18b5dfe",
                    "fq_address": "A.0x9eca2b38b18b5dfe.FlowIDTableStaking",
                    "contract": "FlowIDTableStaking",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 74762620
                  },
                  "mainnet": {
                    "address": "0x8624b52f9ddcd04a",
                    "fq_address": "A.0x8624b52f9ddcd04a.FlowIDTableStaking",
                    "contract": "FlowIDTableStaking",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 34157509
                  }
                }
              },
              "0xLOCKEDTOKENADDRESS": {
                "LockedTokens": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.LockedTokens",
                    "contract": "LockedTokens",
                    "pin": "7c7ff03a10696b7639f235e42b57becdfbdbcee1bb6f99d01f922d4554fe51f0",
                    "pin_block_height": 74762620
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.LockedTokens",
                    "contract": "LockedTokens",
                    "pin": "7c7ff03a10696b7639f235e42b57becdfbdbcee1bb6f99d01f922d4554fe51f0",
                    "pin_block_height": 34157509
                  }
                }
              },
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74762620
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34157509
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7b581646d265ec6ed4a0d29c809ae6f0adafe56794d6a9eb162513187c43befc",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Stake New Tokens"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Stakes new tokens for a stake held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Commits new tokens to stake for the specified node or delegator in the staking collection\n/// The tokens from the locked vault are used first, if it exists\n/// followed by the tokens from the unlocked vault\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.stakeNewTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74561022
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34027702
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The delegator ID"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 2,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of FLOW tokens to stake"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "b9f4fe796cb86959c549e7b2412c51607622d7d9ba891425ed6c4640e730178a",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Stake Rewarded Tokens"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Stakes rewarded tokens for a stake held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Commits rewarded tokens to stake for the specified node or delegator in the staking collection\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.stakeRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74561128
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34027770
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The delegator ID"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 2,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of rewarded tokens to restake"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7bc3056ba5d39d130f45411c2c05bb549db8ce727c11a1cb821136a621be27fb",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Stake Unstaked Tokens"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Stakes unstaked tokens for a stake held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Commits unstaked tokens to stake for the specified node or delegator in the staking collection\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.stakeUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74561240
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34027842
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The delegator ID"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 2,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of unstaked tokens to restake"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "753a69b813b6bc62ba5e83d929e402f97ad75e925133a993354a6708c134eea5",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Transfer Delegation"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Transfers a delegation from one Staking Collection to another"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n// Transfers a NodeDelegator object from an authorizers accoount\n// and adds the NodeDelegator to another accounts Staking Collection\n// identified by the to Address.\ntransaction(nodeID: String, delegatorID: UInt32, to: Address) {\n    let fromStakingCollectionRef: &FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: &FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}\n    prepare(account: AuthAccount) {\n        // The account to transfer the NodeDelegator object to must have a valid Staking Collection in order to receive the NodeDelegator.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        // Get the PublicAccount of the account to transfer the NodeDelegator to. \n        let toAccount = getAccount(to)\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.getCapability<&FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}>(FlowStakingCollection.StakingCollectionPublicPath).borrow()\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        // Remove the NodeDelegator from the authorizers StakingCollection.\n        let nodeDelegator <- self.fromStakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)\n        // Deposit the NodeDelegator to the receivers StakingCollection.\n        self.toStakingCollectionCap.addDelegatorObject(<- nodeDelegator!)\n    }\n}",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74763025
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34157768
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Delegator ID"
                    }
                  }
                },
                "balance": ""
              },
              "to": {
                "index": 2,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The account to transfer to"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "b8299dbdf3c38ea0a99063c4b2bbe4ea950c488f7e66795d032b312a3a9c4dcc",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Transfer Node"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Transfers a Node from one Staking Collection to another"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n// Transfers a NodeStaker object from an authorizers accoount\n// and adds the NodeStaker to another accounts Staking Collection\n// identified by the to Address.\ntransaction(nodeID: String, to: Address) {\n    let fromStakingCollectionRef: &FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: &FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}\n    prepare(account: AuthAccount) {\n        // The account to transfer the NodeStaker object to must have a valid Staking Collection in order to receive the NodeStaker.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        // Get the PublicAccount of the account to transfer the NodeStaker to. \n        let toAccount = getAccount(to)\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.getCapability<&FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}>(FlowStakingCollection.StakingCollectionPublicPath).borrow()\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        let machineAccountInfo = self.fromStakingCollectionRef.getMachineAccounts()[nodeID]\n            ?? panic(\"Could not get machine account info for the specified node ID\")\n        // Remove the NodeStaker from the authorizers StakingCollection.\n        let nodeStaker <- self.fromStakingCollectionRef.removeNode(nodeID: nodeID)\n        // Deposit the NodeStaker to the receivers StakingCollection.\n        self.toStakingCollectionCap.addNodeObject(<- nodeStaker!, machineAccountInfo: machineAccountInfo)\n    }\n}",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74762847
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34157658
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Node ID"
                    }
                  }
                },
                "balance": ""
              },
              "to": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The account to transfer to"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "00d2d230282e78ef38c85eb6ca5423158d6ab5905bf5bd541825588caf9dcd32",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Request Unstaking"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Requests unstaking for a stake held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Requests to unstake ALL tokens for the specified node or delegator in the staking collection\ntransaction(nodeID: String) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.unstakeAll(nodeID: nodeID)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74763406
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34158006
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Node ID"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "544acba77bdc712251cd81befa5cb97414928c7ace95eb6a5aeb4fac133b861f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Update Networking Address"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Updates the networking address for a node held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Changes the networking address for the specified node\ntransaction(nodeID: String, newAddress: String) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.updateNetworkingAddress(nodeID: nodeID, newAddress: newAddress)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74763522
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34158081
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Node ID"
                    }
                  }
                },
                "balance": ""
              },
              "newAddress": {
                "index": 1,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The new Networking Address for this node"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "9f5ee4feb3ffe7a6a20a72d8d2e7878d4d548216c947c95e7ce067fe471217f0",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Withdraw FLOW from Machine Account"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Withdraws FLOW from a machine account"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Request to withdraw tokens from the machine account\n/// The tokens are automatically deposited to the unlocked account vault\ntransaction(nodeID: String, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.withdrawFromMachineAccount(nodeID: nodeID, amount: amount)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74763650
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34158165
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The Node ID"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 1,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount to withdraw"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "6b2739fc0b8114047180badbee699fe6a5d4fb3b74753c35c4f170c30572db1b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Withdraw Rewarded Tokens"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Withdraws rewarded tokens from a stake held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Request to withdraw rewarded tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74561368
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34027928
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The delegator ID"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 2,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of rewarded tokens to withdraw"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ac864a47c36182a1ef29fda5680a45ef5c750543409abc4310b1ef962e1cf128",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Withdraw Unstaked Tokens"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Withdraws unstaked tokens from a stake held in a Staking Collection"
                }
              }
            },
            "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Request to withdraw unstaked tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault if it is there\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
            "dependencies": {
              "0xSTAKINGCOLLECTIONADDRESS": {
                "FlowStakingCollection": {
                  "testnet": {
                    "address": "0x95e019a17d0e23d7",
                    "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 74561496
                  },
                  "mainnet": {
                    "address": "0x8d0e87b65159ae63",
                    "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
                    "contract": "FlowStakingCollection",
                    "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
                    "pin_block_height": 34028006
                  }
                }
              }
            },
            "arguments": {
              "nodeID": {
                "index": 0,
                "type": "String",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The node ID"
                    }
                  }
                },
                "balance": ""
              },
              "delegatorID": {
                "index": 1,
                "type": "UInt32?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The delegator ID"
                    }
                  }
                },
                "balance": ""
              },
              "amount": {
                "index": 2,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The amount of unstaked tokens to withdraw"
                    }
                  }
                },
                "balance": ""
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "062e2cc6c0127b55222ec1cd496f1a97ca1056c04907e3d3889a95ddbe558e97",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Backpack NFTs"
                }
              }
            },
            "cadence": "import Backpack from 0xBackpack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Backpack\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Backpack.Collection>(from: /storage/BackpackCollection) == nil {\n      let collection <- Backpack.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BackpackCollection)\n    }\n    if (signer.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection).borrow() == nil) {\n      signer.unlink(/public/BackpackCollection)\n      signer.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection, target: /storage/BackpackCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xBackpack": {
                "Backpack": {
                  "mainnet": {
                    "address": "0x807c3d470888cc48",
                    "contract": "Backpack",
                    "fq_address": "A.0x807c3d470888cc48.Backpack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47501583
                  },
                  "testnet": {
                    "address": "0xe666c53e1758dec6",
                    "contract": "Backpack",
                    "fq_address": "A.0xe666c53e1758dec6.Backpack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95799415
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501602
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799422
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501609
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799431
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ade4d51f6371708cae541849bdb2f08fdda8d37721e6bc70758969d5ec5b4040",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Backpack NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Backpack from 0xBackpack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Backpack\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Backpack.Collection>(from: /storage/BackpackCollection) == nil {\n            let collection <- Backpack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BackpackCollection)\n            }\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection).borrow() == nil) {\n            acct.unlink(/public/BackpackCollection)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection, target: /storage/BackpackCollection)\n        }\n\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/BackpackPrivateProvider)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider, target: /storage/BackpackCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BackpackCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xBackpack": {
                "Backpack": {
                  "mainnet": {
                    "address": "0x807c3d470888cc48",
                    "contract": "Backpack",
                    "fq_address": "A.0x807c3d470888cc48.Backpack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47501687
                  },
                  "testnet": {
                    "address": "0xe666c53e1758dec6",
                    "contract": "Backpack",
                    "fq_address": "A.0xe666c53e1758dec6.Backpack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95799535
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501703
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799542
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501712
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799552
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47501716
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95799554
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501719
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799555
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501723
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799565
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ba01bc3178d7f4328cb8552dea38bfbe1033954b55eed1910f54cd45d0f36603",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Backpack NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Backpack from 0xBackpack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Backpack\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Backpack.Collection>(from: /storage/BackpackCollection) == nil {\n            let collection <- Backpack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BackpackCollection)\n        }\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection).borrow() == nil) {\n            acct.unlink(/public/BackpackCollection)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection, target: /storage/BackpackCollection)\n        }\n\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/BackpackPrivateProvider)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider, target: /storage/BackpackCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/BackpackPrivateProvider)!\n        let collectionRef = acct\n            .getCapability(/public/BackpackCollection)\n            .borrow<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Backpack.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xBackpack": {
                "Backpack": {
                  "mainnet": {
                    "address": "0x807c3d470888cc48",
                    "contract": "Backpack",
                    "fq_address": "A.0x807c3d470888cc48.Backpack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47501629
                  },
                  "testnet": {
                    "address": "0xe666c53e1758dec6",
                    "contract": "Backpack",
                    "fq_address": "A.0xe666c53e1758dec6.Backpack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95799469
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501646
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799476
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501654
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799486
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47501658
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95799488
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501661
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799489
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501665
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799498
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "2a8685ede4493ac45b1958bb99e82ff4173d853e6c205531791e1e9105b323c8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support BarterYardClubWerewolves NFTs"
                }
              }
            },
            "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: BarterYardClubWerewolves\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n      let collection <- BarterYardClubWerewolf.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n    }\n    if (signer.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n      signer.unlink(/public/BarterYardClubWerewolfCollection)\n      signer.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xBarterYardClubWerewolf": {
                "BarterYardClubWerewolf": {
                  "testnet": {
                    "address": "0x195caada038c5806",
                    "contract": "BarterYardClubWerewolf",
                    "fq_address": "A.0x195caada038c5806.BarterYardClubWerewolf",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95813404
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813408
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813413
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "a1c79169622fcdd99dd150c5a6710e41f404ad27009ff8653c0d6b52ede80c2f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed BarterYardClubWerewolves NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: BarterYardClubWerewolves\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n            let collection <- BarterYardClubWerewolf.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n            }\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/public/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection).borrow() == nil) {\n            acct.unlink(/private/FlovatarCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BarterYardClubWerewolfCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xBarterYardClubWerewolf": {
                "BarterYardClubWerewolf": {
                  "testnet": {
                    "address": "0x195caada038c5806",
                    "contract": "BarterYardClubWerewolf",
                    "fq_address": "A.0x195caada038c5806.BarterYardClubWerewolf",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95813451
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813454
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813459
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813460
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813460
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813464
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e8849742ecde3bbc0cd1c78bfb53d8c028dbbe60862f4ae91283ef60d8970092",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a BarterYardClubWerewolves NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: BarterYardClubWerewolves\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n            let collection <- BarterYardClubWerewolf.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n        }\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/public/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection).borrow() == nil) {\n            acct.unlink(/private/FlovatarCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlovatarCollection)!\n        let collectionRef = acct\n            .getCapability(/public/BarterYardClubWerewolfCollection)\n            .borrow<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@BarterYardClubWerewolf.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xBarterYardClubWerewolf": {
                "BarterYardClubWerewolf": {
                  "testnet": {
                    "address": "0x195caada038c5806",
                    "contract": "BarterYardClubWerewolf",
                    "fq_address": "A.0x195caada038c5806.BarterYardClubWerewolf",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95813424
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813427
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813432
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813433
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813434
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813439
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "d6c7a65f29f29a6df6a78c528e32d03e53036d916c3bb43502d31de7f77e1d50",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Bitku NFTs"
                }
              }
            },
            "cadence": "import HaikuNFT from 0xHaikuNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Bitku\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&HaikuNFT.Collection>(from: /storage/BitkuCollection) == nil {\n      let collection <- HaikuNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BitkuCollection)\n    }\n    if (signer.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection).borrow() == nil) {\n      signer.unlink(/public/BitkuCollection)\n      signer.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection, target: /storage/BitkuCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xHaikuNFT": {
                "HaikuNFT": {
                  "mainnet": {
                    "address": "0xf61e40c19db2a9e2",
                    "contract": "HaikuNFT",
                    "fq_address": "A.0xf61e40c19db2a9e2.HaikuNFT",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 47499355
                  },
                  "testnet": {
                    "address": "0x824f612f78d34250",
                    "contract": "HaikuNFT",
                    "fq_address": "A.0x824f612f78d34250.HaikuNFT",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 95796756
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499371
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796763
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499378
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796773
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "012bf7b368d6c95ba31a9c32a3df50f8dc30bd79a1bdafc759c1fe702cc526f6",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Bitku NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import HaikuNFT from 0xHaikuNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Bitku\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HaikuNFT.Collection>(from: /storage/BitkuCollection) == nil {\n            let collection <- HaikuNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BitkuCollection)\n            }\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection).borrow() == nil) {\n            acct.unlink(/public/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection, target: /storage/BitkuCollection)\n        }\n\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection).borrow() == nil) {\n            acct.unlink(/private/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection, target: /storage/BitkuCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BitkuCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xHaikuNFT": {
                "HaikuNFT": {
                  "mainnet": {
                    "address": "0xf61e40c19db2a9e2",
                    "contract": "HaikuNFT",
                    "fq_address": "A.0xf61e40c19db2a9e2.HaikuNFT",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 47499447
                  },
                  "testnet": {
                    "address": "0x824f612f78d34250",
                    "contract": "HaikuNFT",
                    "fq_address": "A.0x824f612f78d34250.HaikuNFT",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 95796870
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499462
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796877
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499471
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796887
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499474
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95796889
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499475
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796890
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499480
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796899
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "54df1394a1886a7eedfd8b74e277a0d38fad4849efc06c71677819b61581375a",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Bitku NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import HaikuNFT from 0xHaikuNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Bitku\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HaikuNFT.Collection>(from: /storage/BitkuCollection) == nil {\n            let collection <- HaikuNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BitkuCollection)\n        }\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection).borrow() == nil) {\n            acct.unlink(/public/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection, target: /storage/BitkuCollection)\n        }\n\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection).borrow() == nil) {\n            acct.unlink(/private/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection, target: /storage/BitkuCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/BitkuCollection)!\n        let collectionRef = acct\n            .getCapability(/public/BitkuCollection)\n            .borrow<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@HaikuNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xHaikuNFT": {
                "HaikuNFT": {
                  "mainnet": {
                    "address": "0xf61e40c19db2a9e2",
                    "contract": "HaikuNFT",
                    "fq_address": "A.0xf61e40c19db2a9e2.HaikuNFT",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 47499396
                  },
                  "testnet": {
                    "address": "0x824f612f78d34250",
                    "contract": "HaikuNFT",
                    "fq_address": "A.0x824f612f78d34250.HaikuNFT",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 95796807
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499412
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796814
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499419
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796823
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499423
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95796826
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499425
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796827
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499429
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796836
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0332a7f481f63eb039dc0fb7d3077b700c7aca741515dd97631574a5181a8645",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support bl0x NFTs"
                }
              }
            },
            "cadence": "import Bl0x from 0xBl0x\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: bl0x\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Bl0x.Collection>(from: /storage/bl0xNFTs) == nil {\n      let collection <- Bl0x.createEmptyCollection()\n      signer.save(<-collection, to: /storage/bl0xNFTs)\n    }\n    if (signer.getCapability<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs).borrow() == nil) {\n      signer.unlink(/public/bl0xNFTs)\n      signer.link<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs, target: /storage/bl0xNFTs)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xBl0x": {
                "Bl0x": {
                  "mainnet": {
                    "address": "0x7620acf6d7f2468a",
                    "contract": "Bl0x",
                    "fq_address": "A.0x7620acf6d7f2468a.Bl0x",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47507881
                  },
                  "testnet": {
                    "address": "0xe8124d8428980aa6",
                    "contract": "Bl0x",
                    "fq_address": "A.0xe8124d8428980aa6.Bl0x",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95806895
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507897
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806903
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507905
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806913
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "b4e5fc73224e90600e64eb0eb186ce1565807460872651301f83dfadf0d14e69",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed bl0x NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Bl0x from 0xBl0x\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: bl0x\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Bl0x.Collection>(from: /storage/bl0xNFTs) == nil {\n            let collection <- Bl0x.createEmptyCollection()\n            acct.save(<-collection, to: /storage/bl0xNFTs)\n            }\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/public/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/private/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/bl0xNFTs\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xBl0x": {
                "Bl0x": {
                  "mainnet": {
                    "address": "0x7620acf6d7f2468a",
                    "contract": "Bl0x",
                    "fq_address": "A.0x7620acf6d7f2468a.Bl0x",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47507964
                  },
                  "testnet": {
                    "address": "0xe8124d8428980aa6",
                    "contract": "Bl0x",
                    "fq_address": "A.0xe8124d8428980aa6.Bl0x",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95806999
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507981
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807007
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507989
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807017
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507995
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95807019
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507996
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807020
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508000
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807030
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "6f43415e5c9fdac093f6f1b6a115921f2e97430572651d060aa1454877d16c5f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a bl0x NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Bl0x from 0xBl0x\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: bl0x\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Bl0x.Collection>(from: /storage/bl0xNFTs) == nil {\n            let collection <- Bl0x.createEmptyCollection()\n            acct.save(<-collection, to: /storage/bl0xNFTs)\n        }\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/public/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/private/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/bl0xNFTs)!\n        let collectionRef = acct\n            .getCapability(/public/bl0xNFTs)\n            .borrow<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Bl0x.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xBl0x": {
                "Bl0x": {
                  "mainnet": {
                    "address": "0x7620acf6d7f2468a",
                    "contract": "Bl0x",
                    "fq_address": "A.0x7620acf6d7f2468a.Bl0x",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47507916
                  },
                  "testnet": {
                    "address": "0xe8124d8428980aa6",
                    "contract": "Bl0x",
                    "fq_address": "A.0xe8124d8428980aa6.Bl0x",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95806940
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507934
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806947
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507942
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806957
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507947
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95806960
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507949
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806961
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507954
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806970
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "65f83db335d61ac60ac306d5db70624b05ab5ccabc526bad14f8cb1f80d9b0ed",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support BlovizeNFTTrophies NFTs"
                }
              }
            },
            "cadence": "import BlovizeNFT from 0xBlovizeNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: BlovizeNFTTrophies\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&BlovizeNFT.Collection>(from: /storage/blovizeNFTCollection) == nil {\n      let collection <- BlovizeNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/blovizeNFTCollection)\n    }\n    if (signer.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection).borrow() == nil) {\n      signer.unlink(/public/blovizeNFTCollection)\n      signer.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xBlovizeNFT": {
                "BlovizeNFT": {
                  "mainnet": {
                    "address": "0xee4567ab7f63abf2",
                    "contract": "BlovizeNFT",
                    "fq_address": "A.0xee4567ab7f63abf2.BlovizeNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47506077
                  },
                  "testnet": {
                    "address": "0xc8f7112fa2f1af97",
                    "contract": "BlovizeNFT",
                    "fq_address": "A.0xc8f7112fa2f1af97.BlovizeNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804756
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506089
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804763
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506096
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804772
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "9fb6a12224795e886059b8f581e14fca14ab773618f75d6afea419533355621f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed BlovizeNFTTrophies NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import BlovizeNFT from 0xBlovizeNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: BlovizeNFTTrophies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BlovizeNFT.Collection>(from: /storage/blovizeNFTCollection) == nil {\n            let collection <- BlovizeNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/blovizeNFTCollection)\n            }\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/public/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/private/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/blovizeNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xBlovizeNFT": {
                "BlovizeNFT": {
                  "mainnet": {
                    "address": "0xee4567ab7f63abf2",
                    "contract": "BlovizeNFT",
                    "fq_address": "A.0xee4567ab7f63abf2.BlovizeNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47506149
                  },
                  "testnet": {
                    "address": "0xc8f7112fa2f1af97",
                    "contract": "BlovizeNFT",
                    "fq_address": "A.0xc8f7112fa2f1af97.BlovizeNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804838
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506160
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804845
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506167
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804854
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506174
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804857
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506175
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804858
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506179
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804867
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "3559ce85a02d837f51c5ecfb7541b47514513e7295d684a978877a6df92df318",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a BlovizeNFTTrophies NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import BlovizeNFT from 0xBlovizeNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: BlovizeNFTTrophies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BlovizeNFT.Collection>(from: /storage/blovizeNFTCollection) == nil {\n            let collection <- BlovizeNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/blovizeNFTCollection)\n        }\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/public/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/private/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/blovizeNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/blovizeNFTCollection)\n            .borrow<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@BlovizeNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xBlovizeNFT": {
                "BlovizeNFT": {
                  "mainnet": {
                    "address": "0xee4567ab7f63abf2",
                    "contract": "BlovizeNFT",
                    "fq_address": "A.0xee4567ab7f63abf2.BlovizeNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47506108
                  },
                  "testnet": {
                    "address": "0xc8f7112fa2f1af97",
                    "contract": "BlovizeNFT",
                    "fq_address": "A.0xc8f7112fa2f1af97.BlovizeNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804790
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506120
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804797
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506126
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804807
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506131
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804809
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506132
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804810
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506137
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804819
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "55fc46f67fcf45a516233aa351eea0af196279d142ce114e7912a73b7ac27694",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support ChainmonstersRewards NFTs"
                }
              }
            },
            "cadence": "import ChainmonstersRewards from 0xChainmonstersRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ChainmonstersRewards\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ChainmonstersRewards.Collection>(from: /storage/ChainmonstersRewardCollection) == nil {\n      let collection <- ChainmonstersRewards.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ChainmonstersRewardCollection)\n    }\n    if (signer.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection).borrow() == nil) {\n      signer.unlink(/public/ChainmonstersRewardCollection)\n      signer.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection, target: /storage/ChainmonstersRewardCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xChainmonstersRewards": {
                "ChainmonstersRewards": {
                  "mainnet": {
                    "address": "0x93615d25d14fa337",
                    "contract": "ChainmonstersRewards",
                    "fq_address": "A.0x93615d25d14fa337.ChainmonstersRewards",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47497490
                  },
                  "testnet": {
                    "address": "0x75783e3c937304a8",
                    "contract": "ChainmonstersRewards",
                    "fq_address": "A.0x75783e3c937304a8.ChainmonstersRewards",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95794527
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497500
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794534
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497507
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794543
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ae3ef7e28d0044969af4c06bfc4c64e997dee8a52ee23823aaebc175128afce6",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed ChainmonstersRewards NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import ChainmonstersRewards from 0xChainmonstersRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ChainmonstersRewards\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ChainmonstersRewards.Collection>(from: /storage/ChainmonstersRewardCollection) == nil {\n            let collection <- ChainmonstersRewards.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ChainmonstersRewardCollection)\n            }\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection).borrow() == nil) {\n            acct.unlink(/public/ChainmonstersRewardCollection)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection, target: /storage/ChainmonstersRewardCollection)\n        }\n\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/ChainmonstersRewardsCollectionProvider)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider, target: /storage/ChainmonstersRewardCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ChainmonstersRewardCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xChainmonstersRewards": {
                "ChainmonstersRewards": {
                  "mainnet": {
                    "address": "0x93615d25d14fa337",
                    "contract": "ChainmonstersRewards",
                    "fq_address": "A.0x93615d25d14fa337.ChainmonstersRewards",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47497562
                  },
                  "testnet": {
                    "address": "0x75783e3c937304a8",
                    "contract": "ChainmonstersRewards",
                    "fq_address": "A.0x75783e3c937304a8.ChainmonstersRewards",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95794613
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497573
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794620
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497581
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794630
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47497585
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95794632
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497587
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794633
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497591
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794643
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "5644d68c138ef683710bc7074f396d95c6d6484a6da8de77b803ec6cc1abbabd",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a ChainmonstersRewards NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import ChainmonstersRewards from 0xChainmonstersRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ChainmonstersRewards\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ChainmonstersRewards.Collection>(from: /storage/ChainmonstersRewardCollection) == nil {\n            let collection <- ChainmonstersRewards.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ChainmonstersRewardCollection)\n        }\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection).borrow() == nil) {\n            acct.unlink(/public/ChainmonstersRewardCollection)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection, target: /storage/ChainmonstersRewardCollection)\n        }\n\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/ChainmonstersRewardsCollectionProvider)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider, target: /storage/ChainmonstersRewardCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ChainmonstersRewardsCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/ChainmonstersRewardCollection)\n            .borrow<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@ChainmonstersRewards.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xChainmonstersRewards": {
                "ChainmonstersRewards": {
                  "mainnet": {
                    "address": "0x93615d25d14fa337",
                    "contract": "ChainmonstersRewards",
                    "fq_address": "A.0x93615d25d14fa337.ChainmonstersRewards",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47497517
                  },
                  "testnet": {
                    "address": "0x75783e3c937304a8",
                    "contract": "ChainmonstersRewards",
                    "fq_address": "A.0x75783e3c937304a8.ChainmonstersRewards",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95794564
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497530
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794571
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497538
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794581
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47497543
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95794583
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497544
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794584
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497547
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794594
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e888652cd84c570f22912beb53fdea08cd06c53dc41824a08978ef845d7848b8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support CryptoPiggoNFTCollection NFTs"
                }
              }
            },
            "cadence": "import CryptoPiggo from 0xCryptoPiggo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CryptoPiggoNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CryptoPiggo.Collection>(from: /storage/CryptoPiggoCollection) == nil {\n      let collection <- CryptoPiggo.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CryptoPiggoCollection)\n    }\n    if (signer.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection).borrow() == nil) {\n      signer.unlink(/public/CryptoPiggoCollection)\n      signer.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xCryptoPiggo": {
                "CryptoPiggo": {
                  "mainnet": {
                    "address": "0xd3df824bf81910a4",
                    "contract": "CryptoPiggo",
                    "fq_address": "A.0xd3df824bf81910a4.CryptoPiggo",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505957
                  },
                  "testnet": {
                    "address": "0x57e1b27618c5bb69",
                    "contract": "CryptoPiggo",
                    "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggo",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804613
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505967
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804621
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505973
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804631
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "c87fc8b202dd7efcdc1bd64a99ab3ac4a187633be33476af01b810817b98af94",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed CryptoPiggoNFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CryptoPiggo from 0xCryptoPiggo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CryptoPiggoNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggo.Collection>(from: /storage/CryptoPiggoCollection) == nil {\n            let collection <- CryptoPiggo.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoCollection)\n            }\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CryptoPiggoCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xCryptoPiggo": {
                "CryptoPiggo": {
                  "mainnet": {
                    "address": "0xd3df824bf81910a4",
                    "contract": "CryptoPiggo",
                    "fq_address": "A.0xd3df824bf81910a4.CryptoPiggo",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47506028
                  },
                  "testnet": {
                    "address": "0x57e1b27618c5bb69",
                    "contract": "CryptoPiggo",
                    "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggo",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804699
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506039
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804705
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506046
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804715
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506051
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804718
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506053
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804719
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506057
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804728
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "def1d535116f42adfb54b210262cedb01c7f53a81939f7a0e13a601e07410b46",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a CryptoPiggoNFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CryptoPiggo from 0xCryptoPiggo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CryptoPiggoNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggo.Collection>(from: /storage/CryptoPiggoCollection) == nil {\n            let collection <- CryptoPiggo.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoCollection)\n        }\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CryptoPiggoCollection)!\n        let collectionRef = acct\n            .getCapability(/public/CryptoPiggoCollection)\n            .borrow<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CryptoPiggo.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xCryptoPiggo": {
                "CryptoPiggo": {
                  "mainnet": {
                    "address": "0xd3df824bf81910a4",
                    "contract": "CryptoPiggo",
                    "fq_address": "A.0xd3df824bf81910a4.CryptoPiggo",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505987
                  },
                  "testnet": {
                    "address": "0x57e1b27618c5bb69",
                    "contract": "CryptoPiggo",
                    "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggo",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804650
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505998
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804657
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506005
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804667
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506009
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804669
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506011
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804670
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506016
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804680
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "29676248d93ef6de6d43d2f4c26438e047b928c531b0a07e68026ab484708148",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support CryptoPiggoV2NFTCollection NFTs"
                }
              }
            },
            "cadence": "import CryptoPiggoV2 from 0xCryptoPiggoV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CryptoPiggoV2NFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CryptoPiggoV2.Collection>(from: /storage/CryptoPiggoV2Collection) == nil {\n      let collection <- CryptoPiggoV2.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CryptoPiggoV2Collection)\n    }\n    if (signer.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection).borrow() == nil) {\n      signer.unlink(/public/CryptoPiggoV2Collection)\n      signer.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xCryptoPiggoV2": {
                "CryptoPiggoV2": {
                  "mainnet": {
                    "address": "0xd3df824bf81910a4",
                    "contract": "CryptoPiggoV2",
                    "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoV2",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47504878
                  },
                  "testnet": {
                    "address": "0x57e1b27618c5bb69",
                    "contract": "CryptoPiggoV2",
                    "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggoV2",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95803312
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47504890
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803319
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47504898
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803329
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "d11f0e32c5cd012a5661a820db4c6db7602d2ff896eea8ab9226fb300782cefa",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed CryptoPiggoV2NFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CryptoPiggoV2 from 0xCryptoPiggoV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CryptoPiggoV2NFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggoV2.Collection>(from: /storage/CryptoPiggoV2Collection) == nil {\n            let collection <- CryptoPiggoV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoV2Collection)\n            }\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CryptoPiggoV2Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xCryptoPiggoV2": {
                "CryptoPiggoV2": {
                  "mainnet": {
                    "address": "0xd3df824bf81910a4",
                    "contract": "CryptoPiggoV2",
                    "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoV2",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47504954
                  },
                  "testnet": {
                    "address": "0x57e1b27618c5bb69",
                    "contract": "CryptoPiggoV2",
                    "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggoV2",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95803398
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47504965
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803406
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47504972
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803415
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47504978
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95803418
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47504979
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803419
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47504983
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803429
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "14d11ff5da9d4a6d32e3208c12c0c8eec76dc0b8027617a7bedb55b2e2206d40",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a CryptoPiggoV2NFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CryptoPiggoV2 from 0xCryptoPiggoV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CryptoPiggoV2NFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggoV2.Collection>(from: /storage/CryptoPiggoV2Collection) == nil {\n            let collection <- CryptoPiggoV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoV2Collection)\n        }\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CryptoPiggoV2Collection)!\n        let collectionRef = acct\n            .getCapability(/public/CryptoPiggoV2Collection)\n            .borrow<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CryptoPiggoV2.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xCryptoPiggoV2": {
                "CryptoPiggoV2": {
                  "mainnet": {
                    "address": "0xd3df824bf81910a4",
                    "contract": "CryptoPiggoV2",
                    "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoV2",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47504912
                  },
                  "testnet": {
                    "address": "0x57e1b27618c5bb69",
                    "contract": "CryptoPiggoV2",
                    "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggoV2",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95803350
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47504923
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803357
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47504929
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803366
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47504935
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95803368
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47504935
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803369
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47504940
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803379
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "073b2cc13a713061ed58772a7809d06fb3e36feb8bd632b1245c6e3919eee742",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support CuveeCollectiveCollector NFTs"
                }
              }
            },
            "cadence": "import Collector from 0xCollector\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CuveeCollectiveCollector\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Collector.Collection>(from: /storage/CollectorCollection) == nil {\n      let collection <- Collector.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CollectorCollection)\n    }\n    if (signer.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection).borrow() == nil) {\n      signer.unlink(/public/CollectorCollection)\n      signer.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection, target: /storage/CollectorCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xCollector": {
                "Collector": {
                  "mainnet": {
                    "address": "0x7c8995e83c4b1843",
                    "contract": "Collector",
                    "fq_address": "A.0x7c8995e83c4b1843.Collector",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47509173
                  },
                  "testnet": {
                    "address": "0x3a1ebf12b8e3da71",
                    "contract": "Collector",
                    "fq_address": "A.0x3a1ebf12b8e3da71.Collector",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95808430
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509183
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808437
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509190
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808446
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "56a394e9f8f1657a408e762aab4315e32205b3b7b9adeb9f629f15cc2e1454fa",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed CuveeCollectiveCollector NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Collector from 0xCollector\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CuveeCollectiveCollector\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Collector.Collection>(from: /storage/CollectorCollection) == nil {\n            let collection <- Collector.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CollectorCollection)\n            }\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection).borrow() == nil) {\n            acct.unlink(/public/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection, target: /storage/CollectorCollection)\n        }\n\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection).borrow() == nil) {\n            acct.unlink(/private/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection, target: /storage/CollectorCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CollectorCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xCollector": {
                "Collector": {
                  "mainnet": {
                    "address": "0x7c8995e83c4b1843",
                    "contract": "Collector",
                    "fq_address": "A.0x7c8995e83c4b1843.Collector",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47509240
                  },
                  "testnet": {
                    "address": "0x3a1ebf12b8e3da71",
                    "contract": "Collector",
                    "fq_address": "A.0x3a1ebf12b8e3da71.Collector",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95808513
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509250
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808521
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509257
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808530
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47509261
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95808532
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509263
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808533
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509267
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808543
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "c6a1914094db3e389250c93eb04e3fbef51b165eb77c8a62c4705d939dd53bb7",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a CuveeCollectiveCollector NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Collector from 0xCollector\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CuveeCollectiveCollector\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Collector.Collection>(from: /storage/CollectorCollection) == nil {\n            let collection <- Collector.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CollectorCollection)\n        }\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection).borrow() == nil) {\n            acct.unlink(/public/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection, target: /storage/CollectorCollection)\n        }\n\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection).borrow() == nil) {\n            acct.unlink(/private/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection, target: /storage/CollectorCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CollectorCollection)!\n        let collectionRef = acct\n            .getCapability(/public/CollectorCollection)\n            .borrow<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Collector.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xCollector": {
                "Collector": {
                  "mainnet": {
                    "address": "0x7c8995e83c4b1843",
                    "contract": "Collector",
                    "fq_address": "A.0x7c8995e83c4b1843.Collector",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47509201
                  },
                  "testnet": {
                    "address": "0x3a1ebf12b8e3da71",
                    "contract": "Collector",
                    "fq_address": "A.0x3a1ebf12b8e3da71.Collector",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95808466
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509210
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808472
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509217
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808482
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47509222
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95808484
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509223
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808485
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509227
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808494
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ed58b65fc9d5500c4aa8ad33f5685e32358ea674f2cb57b996afbd09c68f59d9",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Driverz NFTs"
                }
              }
            },
            "cadence": "import DriverzNFT from 0xDriverzNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Driverz\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DriverzNFT.Collection>(from: /storage/DriverzNFTCollection) == nil {\n      let collection <- DriverzNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DriverzNFTCollection)\n    }\n    if (signer.getCapability<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection).borrow() == nil) {\n      signer.unlink(/public/DriverzNFTCollection)\n      signer.link<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xDriverzNFT": {
                "DriverzNFT": {
                  "mainnet": {
                    "address": "0xa039bd7d55a96c0c",
                    "contract": "DriverzNFT",
                    "fq_address": "A.0xa039bd7d55a96c0c.DriverzNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499710
                  },
                  "testnet": {
                    "address": "0xf44b704689c35798",
                    "contract": "DriverzNFT",
                    "fq_address": "A.0xf44b704689c35798.DriverzNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797175
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499724
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797182
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499731
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797191
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "5f9fa3e9e2df8eb853bd234b3c4595afb8fd19a061997d4c3d770d956b7ebda2",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Driverz NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import DriverzNFT from 0xDriverzNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Driverz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DriverzNFT.Collection>(from: /storage/DriverzNFTCollection) == nil {\n            let collection <- DriverzNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DriverzNFTCollection)\n            }\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/private/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DriverzNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xDriverzNFT": {
                "DriverzNFT": {
                  "mainnet": {
                    "address": "0xa039bd7d55a96c0c",
                    "contract": "DriverzNFT",
                    "fq_address": "A.0xa039bd7d55a96c0c.DriverzNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499787
                  },
                  "testnet": {
                    "address": "0xf44b704689c35798",
                    "contract": "DriverzNFT",
                    "fq_address": "A.0xf44b704689c35798.DriverzNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797259
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499799
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797266
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499806
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797276
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499810
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95797278
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499813
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797279
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499817
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797289
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "8ebf160b72e542d5075548dac19fb26d1a7ffd446a255356bfbf792a51b0bd09",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Driverz NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import DriverzNFT from 0xDriverzNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Driverz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DriverzNFT.Collection>(from: /storage/DriverzNFTCollection) == nil {\n            let collection <- DriverzNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DriverzNFTCollection)\n        }\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/private/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DriverzNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/DriverzNFTCollection)\n            .borrow<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DriverzNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xDriverzNFT": {
                "DriverzNFT": {
                  "mainnet": {
                    "address": "0xa039bd7d55a96c0c",
                    "contract": "DriverzNFT",
                    "fq_address": "A.0xa039bd7d55a96c0c.DriverzNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499742
                  },
                  "testnet": {
                    "address": "0xf44b704689c35798",
                    "contract": "DriverzNFT",
                    "fq_address": "A.0xf44b704689c35798.DriverzNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797210
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499754
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797217
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499762
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797226
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499767
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95797229
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499769
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797230
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499773
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797239
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "cfd0c25234b8993aa947b0407d04b977f65daeb7ea02e2d7064ef16c39f50f47",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support FLOAT NFTs"
                }
              }
            },
            "cadence": "import FLOAT from 0xFLOAT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FLOAT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FLOAT.Collection>(from: /storage/FLOATCollectionStoragePath) == nil {\n      let collection <- FLOAT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FLOATCollectionStoragePath)\n    }\n    if (signer.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath).borrow() == nil) {\n      signer.unlink(/public/FLOATCollectionPublicPath)\n      signer.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath, target: /storage/FLOATCollectionStoragePath)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xFLOAT": {
                "FLOAT": {
                  "mainnet": {
                    "address": "0x2d4c3caffbeab845",
                    "contract": "FLOAT",
                    "fq_address": "A.0x2d4c3caffbeab845.FLOAT",
                    "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
                    "pin_block_height": 47505792
                  },
                  "testnet": {
                    "address": "0x0afe396ebc8eee65",
                    "contract": "FLOAT",
                    "fq_address": "A.0x0afe396ebc8eee65.FLOAT",
                    "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
                    "pin_block_height": 95804421
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505811
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804428
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505820
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804438
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "8a590d97dd9f1fbd5c7c40054d0121a26149dac98ddf0dab327553646160111f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed FLOAT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FLOAT from 0xFLOAT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FLOAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FLOAT.Collection>(from: /storage/FLOATCollectionStoragePath) == nil {\n            let collection <- FLOAT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FLOATCollectionStoragePath)\n            }\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/FLOATCollectionPublicPath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath, target: /storage/FLOATCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/FLOATCollectionPrivatePath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath, target: /storage/FLOATCollectionStoragePath)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/FLOATCollectionStoragePath\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xFLOAT": {
                "FLOAT": {
                  "mainnet": {
                    "address": "0x2d4c3caffbeab845",
                    "contract": "FLOAT",
                    "fq_address": "A.0x2d4c3caffbeab845.FLOAT",
                    "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
                    "pin_block_height": 47505899
                  },
                  "testnet": {
                    "address": "0x0afe396ebc8eee65",
                    "contract": "FLOAT",
                    "fq_address": "A.0x0afe396ebc8eee65.FLOAT",
                    "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
                    "pin_block_height": 95804554
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505918
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804561
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505925
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804570
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505929
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804573
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505931
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804574
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505934
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804583
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "dc3e231fc9374a163feecc6f588d03ddc0b998820ca2f438e8d6feea807b6e91",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a FLOAT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FLOAT from 0xFLOAT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FLOAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FLOAT.Collection>(from: /storage/FLOATCollectionStoragePath) == nil {\n            let collection <- FLOAT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FLOATCollectionStoragePath)\n        }\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/FLOATCollectionPublicPath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath, target: /storage/FLOATCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/FLOATCollectionPrivatePath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath, target: /storage/FLOATCollectionStoragePath)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FLOATCollectionPrivatePath)!\n        let collectionRef = acct\n            .getCapability(/public/FLOATCollectionPublicPath)\n            .borrow<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FLOAT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xFLOAT": {
                "FLOAT": {
                  "mainnet": {
                    "address": "0x2d4c3caffbeab845",
                    "contract": "FLOAT",
                    "fq_address": "A.0x2d4c3caffbeab845.FLOAT",
                    "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
                    "pin_block_height": 47505841
                  },
                  "testnet": {
                    "address": "0x0afe396ebc8eee65",
                    "contract": "FLOAT",
                    "fq_address": "A.0x0afe396ebc8eee65.FLOAT",
                    "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
                    "pin_block_height": 95804481
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505864
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804488
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505870
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804497
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505874
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804499
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505876
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804500
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505880
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804510
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "11f09221a5c8404f4c9b6a4db75baee3e1d67d4033432e96fb2445791eaba3d7",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support FlowverseMysteryPass NFTs"
                }
              }
            },
            "cadence": "import FlowversePass from 0xFlowversePass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlowverseMysteryPass\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowversePass.Collection>(from: /storage/FlowversePassCollection) == nil {\n      let collection <- FlowversePass.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FlowversePassCollection)\n    }\n    if (signer.getCapability<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection).borrow() == nil) {\n      signer.unlink(/public/FlowversePassCollection)\n      signer.link<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection, target: /storage/FlowversePassCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xFlowversePass": {
                "FlowversePass": {
                  "mainnet": {
                    "address": "0x9212a87501a8a6a2",
                    "contract": "FlowversePass",
                    "fq_address": "A.0x9212a87501a8a6a2.FlowversePass",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499840
                  },
                  "testnet": {
                    "address": "0xc7c122b5b811de8e",
                    "contract": "FlowversePass",
                    "fq_address": "A.0xc7c122b5b811de8e.FlowversePass",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797320
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499850
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797326
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499856
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797336
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ba9554b7ec84493695b376f3fbe134c7811c43370cea44b00820efc58d71bfaa",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed FlowverseMysteryPass NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FlowversePass from 0xFlowversePass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlowverseMysteryPass\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowversePass.Collection>(from: /storage/FlowversePassCollection) == nil {\n            let collection <- FlowversePass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowversePassCollection)\n            }\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/public/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/private/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/FlowversePassCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xFlowversePass": {
                "FlowversePass": {
                  "mainnet": {
                    "address": "0x9212a87501a8a6a2",
                    "contract": "FlowversePass",
                    "fq_address": "A.0x9212a87501a8a6a2.FlowversePass",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499912
                  },
                  "testnet": {
                    "address": "0xc7c122b5b811de8e",
                    "contract": "FlowversePass",
                    "fq_address": "A.0xc7c122b5b811de8e.FlowversePass",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797404
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499923
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797411
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499931
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797421
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499936
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95797424
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499938
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797425
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499943
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797434
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ca68ee659bd6e6c877dd084a06dd156c062c38ebdafd304d275dd6929d4fc006",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a FlowverseMysteryPass NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FlowversePass from 0xFlowversePass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseMysteryPass\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowversePass.Collection>(from: /storage/FlowversePassCollection) == nil {\n            let collection <- FlowversePass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowversePassCollection)\n        }\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/public/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/private/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlowversePassCollection)!\n        let collectionRef = acct\n            .getCapability(/public/FlowversePassCollection)\n            .borrow<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FlowversePass.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xFlowversePass": {
                "FlowversePass": {
                  "mainnet": {
                    "address": "0x9212a87501a8a6a2",
                    "contract": "FlowversePass",
                    "fq_address": "A.0x9212a87501a8a6a2.FlowversePass",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499869
                  },
                  "testnet": {
                    "address": "0xc7c122b5b811de8e",
                    "contract": "FlowversePass",
                    "fq_address": "A.0xc7c122b5b811de8e.FlowversePass",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797356
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499882
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797362
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499888
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797372
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499894
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95797374
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499894
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797375
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499898
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797384
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "30347fcd18c1531ee1fa54c12822a55ce62011cf27a3e5c042fafc127c4b3ac9",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support FlowverseSocks NFTs"
                }
              }
            },
            "cadence": "import FlowverseSocks01 from 0xFlowverseSocks01\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlowverseSocks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowverseSocks01.Collection>(from: /storage/MatrixMarketFlowverseSocks01Collection) == nil {\n      let collection <- FlowverseSocks01.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MatrixMarketFlowverseSocks01Collection)\n    }\n    if (signer.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection).borrow() == nil) {\n      signer.unlink(/public/MatrixMarketFlowverseSocks01Collection)\n      signer.link<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783908
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783913
                  }
                }
              },
              "0xFlowverseSocks01": {
                "FlowverseSocks01": {
                  "testnet": {
                    "address": "0x7f3812b53dd4de20",
                    "contract": "FlowverseSocks01",
                    "fq_address": "A.0x7f3812b53dd4de20.FlowverseSocks01",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95783922
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "d3357810579ec9dc5dcad55d660f501bcffa0daa8b0e4c43e9d82fe17adcc437",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed FlowverseSocks NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FlowverseSocks01 from 0xFlowverseSocks01\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlowverseSocks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseSocks01.Collection>(from: /storage/MatrixMarketFlowverseSocks01Collection) == nil {\n            let collection <- FlowverseSocks01.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MatrixMarketFlowverseSocks01Collection)\n            }\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/public/MatrixMarketFlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/private/FlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MatrixMarketFlowverseSocks01Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784004
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784009
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95784010
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784011
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784016
                  }
                }
              },
              "0xFlowverseSocks01": {
                "FlowverseSocks01": {
                  "testnet": {
                    "address": "0x7f3812b53dd4de20",
                    "contract": "FlowverseSocks01",
                    "fq_address": "A.0x7f3812b53dd4de20.FlowverseSocks01",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95784025
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "a907880128877fe0b6b3aa7e78f8077dc6b740ae98a314f3704e27b5345890a4",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a FlowverseSocks NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FlowverseSocks01 from 0xFlowverseSocks01\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseSocks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseSocks01.Collection>(from: /storage/MatrixMarketFlowverseSocks01Collection) == nil {\n            let collection <- FlowverseSocks01.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/public/MatrixMarketFlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/private/FlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlowverseSocks01Collection)!\n        let collectionRef = acct\n            .getCapability(/public/MatrixMarketFlowverseSocks01Collection)\n            .borrow<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FlowverseSocks01.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783951
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783956
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95783957
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783958
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783962
                  }
                }
              },
              "0xFlowverseSocks01": {
                "FlowverseSocks01": {
                  "testnet": {
                    "address": "0x7f3812b53dd4de20",
                    "contract": "FlowverseSocks01",
                    "fq_address": "A.0x7f3812b53dd4de20.FlowverseSocks01",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95783973
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7d6b42156b3faf16657b842d7a59b146f66b7918f42e61c2913ce3e52e4d4a09",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support FlowverseTreasures NFTs"
                }
              }
            },
            "cadence": "import FlowverseTreasures from 0xFlowverseTreasures\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlowverseTreasures\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowverseTreasures.Collection>(from: /storage/FlowverseTreasuresCollection) == nil {\n      let collection <- FlowverseTreasures.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FlowverseTreasuresCollection)\n    }\n    if (signer.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection).borrow() == nil) {\n      signer.unlink(/public/FlowverseTreasuresCollection)\n      signer.link<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xFlowverseTreasures": {
                "FlowverseTreasures": {
                  "mainnet": {
                    "address": "0x9212a87501a8a6a2",
                    "contract": "FlowverseTreasures",
                    "fq_address": "A.0x9212a87501a8a6a2.FlowverseTreasures",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47505482
                  },
                  "testnet": {
                    "address": "0xc7c122b5b811de8e",
                    "contract": "FlowverseTreasures",
                    "fq_address": "A.0xc7c122b5b811de8e.FlowverseTreasures",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95804030
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505492
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804037
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505500
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804047
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "09ee97cba9ba4ea3f464812d11d7a61aac3ed96862d86d4c478c4ab8a7c75f7c",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed FlowverseTreasures NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FlowverseTreasures from 0xFlowverseTreasures\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlowverseTreasures\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseTreasures.Collection>(from: /storage/FlowverseTreasuresCollection) == nil {\n            let collection <- FlowverseTreasures.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowverseTreasuresCollection)\n            }\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/public/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/private/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/FlowverseTreasuresCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xFlowverseTreasures": {
                "FlowverseTreasures": {
                  "mainnet": {
                    "address": "0x9212a87501a8a6a2",
                    "contract": "FlowverseTreasures",
                    "fq_address": "A.0x9212a87501a8a6a2.FlowverseTreasures",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47505553
                  },
                  "testnet": {
                    "address": "0xc7c122b5b811de8e",
                    "contract": "FlowverseTreasures",
                    "fq_address": "A.0xc7c122b5b811de8e.FlowverseTreasures",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95804118
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505564
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804125
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505571
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804135
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505574
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804137
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505577
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804139
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505580
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804148
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "634c244bfa429e093b188e519a0df3d7da08f75790e50c44621c83836149337d",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a FlowverseTreasures NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import FlowverseTreasures from 0xFlowverseTreasures\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseTreasures\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseTreasures.Collection>(from: /storage/FlowverseTreasuresCollection) == nil {\n            let collection <- FlowverseTreasures.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowverseTreasuresCollection)\n        }\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/public/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/private/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlowverseTreasuresCollection)!\n        let collectionRef = acct\n            .getCapability(/public/FlowverseTreasuresCollection)\n            .borrow<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FlowverseTreasures.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xFlowverseTreasures": {
                "FlowverseTreasures": {
                  "mainnet": {
                    "address": "0x9212a87501a8a6a2",
                    "contract": "FlowverseTreasures",
                    "fq_address": "A.0x9212a87501a8a6a2.FlowverseTreasures",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47505512
                  },
                  "testnet": {
                    "address": "0xc7c122b5b811de8e",
                    "contract": "FlowverseTreasures",
                    "fq_address": "A.0xc7c122b5b811de8e.FlowverseTreasures",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95804067
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505523
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804074
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505530
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804085
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505535
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804087
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505537
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804088
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505540
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804097
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "de0854e19d6ede95460f69d6af49208780b7d0b6bd5cbe2a1f62d1584368158b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Flunks NFTs"
                }
              }
            },
            "cadence": "import Flunks from 0xFlunks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Flunks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Flunks.Collection>(from: /storage/FlunksCollection) == nil {\n      let collection <- Flunks.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FlunksCollection)\n    }\n    if (signer.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection).borrow() == nil) {\n      signer.unlink(/public/FlunksCollection)\n      signer.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection, target: /storage/FlunksCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xFlunks": {
                "Flunks": {
                  "mainnet": {
                    "address": "0x807c3d470888cc48",
                    "contract": "Flunks",
                    "fq_address": "A.0x807c3d470888cc48.Flunks",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510163
                  },
                  "testnet": {
                    "address": "0xe666c53e1758dec6",
                    "contract": "Flunks",
                    "fq_address": "A.0xe666c53e1758dec6.Flunks",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809591
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510174
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809598
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510180
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809607
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "33925d730e78ad3e2d6a8773fca98466ba2287211f3be7318db91bb75df9f493",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Flunks NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Flunks from 0xFlunks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Flunks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Flunks.Collection>(from: /storage/FlunksCollection) == nil {\n            let collection <- Flunks.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlunksCollection)\n            }\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection).borrow() == nil) {\n            acct.unlink(/public/FlunksCollection)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection, target: /storage/FlunksCollection)\n        }\n\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/FlunksPrivateProvider)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider, target: /storage/FlunksCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/FlunksCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xFlunks": {
                "Flunks": {
                  "mainnet": {
                    "address": "0x807c3d470888cc48",
                    "contract": "Flunks",
                    "fq_address": "A.0x807c3d470888cc48.Flunks",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510235
                  },
                  "testnet": {
                    "address": "0xe666c53e1758dec6",
                    "contract": "Flunks",
                    "fq_address": "A.0xe666c53e1758dec6.Flunks",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809677
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510245
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809684
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510253
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809694
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47510259
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809696
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510259
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809697
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510264
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809706
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "bd4c4df0bdf921d4b375dcd7098f41386c32b8de8ac6e7a309df89355659f0a7",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Flunks NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Flunks from 0xFlunks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Flunks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Flunks.Collection>(from: /storage/FlunksCollection) == nil {\n            let collection <- Flunks.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlunksCollection)\n        }\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection).borrow() == nil) {\n            acct.unlink(/public/FlunksCollection)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection, target: /storage/FlunksCollection)\n        }\n\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/FlunksPrivateProvider)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider, target: /storage/FlunksCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlunksPrivateProvider)!\n        let collectionRef = acct\n            .getCapability(/public/FlunksCollection)\n            .borrow<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Flunks.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xFlunks": {
                "Flunks": {
                  "mainnet": {
                    "address": "0x807c3d470888cc48",
                    "contract": "Flunks",
                    "fq_address": "A.0x807c3d470888cc48.Flunks",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510193
                  },
                  "testnet": {
                    "address": "0xe666c53e1758dec6",
                    "contract": "Flunks",
                    "fq_address": "A.0xe666c53e1758dec6.Flunks",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809627
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510203
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809635
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510210
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809644
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47510215
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809646
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510218
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809648
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510221
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809657
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "40dcbea5bc522ae788fac496b74ebb5cecb752283a35a3a074cf64ade97bb847",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support GoatedGoats NFTs"
                }
              }
            },
            "cadence": "import GoatedGoats from 0xGoatedGoats\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: GoatedGoats\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&GoatedGoats.Collection>(from: /storage/GoatCollection) == nil {\n      let collection <- GoatedGoats.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GoatCollection)\n    }\n    if (signer.getCapability<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection).borrow() == nil) {\n      signer.unlink(/public/GoatCollection)\n      signer.link<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection, target: /storage/GoatCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xGoatedGoats": {
                "GoatedGoats": {
                  "mainnet": {
                    "address": "0x2068315349bdfce5",
                    "contract": "GoatedGoats",
                    "fq_address": "A.0x2068315349bdfce5.GoatedGoats",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47507717
                  },
                  "testnet": {
                    "address": "0x386817f360a5c8df",
                    "contract": "GoatedGoats",
                    "fq_address": "A.0x386817f360a5c8df.GoatedGoats",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95806704
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507740
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806711
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507745
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806721
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "cc424b077227fc24ab3e75f9c0055af4a62ba62a148b8000258594c65b2dbd36",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed GoatedGoats NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import GoatedGoats from 0xGoatedGoats\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: GoatedGoats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoats.Collection>(from: /storage/GoatCollection) == nil {\n            let collection <- GoatedGoats.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatCollection)\n            }\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection).borrow() == nil) {\n            acct.unlink(/public/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection, target: /storage/GoatCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection).borrow() == nil) {\n            acct.unlink(/private/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection, target: /storage/GoatCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/GoatCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xGoatedGoats": {
                "GoatedGoats": {
                  "mainnet": {
                    "address": "0x2068315349bdfce5",
                    "contract": "GoatedGoats",
                    "fq_address": "A.0x2068315349bdfce5.GoatedGoats",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47507826
                  },
                  "testnet": {
                    "address": "0x386817f360a5c8df",
                    "contract": "GoatedGoats",
                    "fq_address": "A.0x386817f360a5c8df.GoatedGoats",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95806828
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507843
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806836
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507850
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806845
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507855
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95806847
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507857
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806848
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507861
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806858
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e2b7644888badded7d3e37d5bf40381303ae643d94e79b8092c712e5456d39cc",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a GoatedGoats NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import GoatedGoats from 0xGoatedGoats\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: GoatedGoats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoats.Collection>(from: /storage/GoatCollection) == nil {\n            let collection <- GoatedGoats.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatCollection)\n        }\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection).borrow() == nil) {\n            acct.unlink(/public/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection, target: /storage/GoatCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection).borrow() == nil) {\n            acct.unlink(/private/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection, target: /storage/GoatCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/GoatCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GoatCollection)\n            .borrow<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@GoatedGoats.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xGoatedGoats": {
                "GoatedGoats": {
                  "mainnet": {
                    "address": "0x2068315349bdfce5",
                    "contract": "GoatedGoats",
                    "fq_address": "A.0x2068315349bdfce5.GoatedGoats",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47507769
                  },
                  "testnet": {
                    "address": "0x386817f360a5c8df",
                    "contract": "GoatedGoats",
                    "fq_address": "A.0x386817f360a5c8df.GoatedGoats",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95806759
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507787
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806766
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507794
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806776
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507799
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95806778
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507801
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806779
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507806
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806789
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e51febd52c5ae906f6a054a4e7cb61f8c75e602639a11249ef4f20aa4bc624e3",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support GoatedGoatsTraits NFTs"
                }
              }
            },
            "cadence": "import GoatedGoatsTrait from 0xGoatedGoatsTrait\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: GoatedGoatsTraits\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&GoatedGoatsTrait.Collection>(from: /storage/GoatTraitCollection) == nil {\n      let collection <- GoatedGoatsTrait.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GoatTraitCollection)\n    }\n    if (signer.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection).borrow() == nil) {\n      signer.unlink(/public/GoatTraitCollection)\n      signer.link<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection, target: /storage/GoatTraitCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xGoatedGoatsTrait": {
                "GoatedGoatsTrait": {
                  "mainnet": {
                    "address": "0x2068315349bdfce5",
                    "contract": "GoatedGoatsTrait",
                    "fq_address": "A.0x2068315349bdfce5.GoatedGoatsTrait",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47493200
                  },
                  "testnet": {
                    "address": "0x386817f360a5c8df",
                    "contract": "GoatedGoatsTrait",
                    "fq_address": "A.0x386817f360a5c8df.GoatedGoatsTrait",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95789426
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47493212
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95789433
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47493218
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95789443
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "acc32e7101cd21151c9b967ac51a913ebfb26912d3e8e5ab9cb99d7c751d2e75",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed GoatedGoatsTraits NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import GoatedGoatsTrait from 0xGoatedGoatsTrait\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: GoatedGoatsTraits\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoatsTrait.Collection>(from: /storage/GoatTraitCollection) == nil {\n            let collection <- GoatedGoatsTrait.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatTraitCollection)\n            }\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/public/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/private/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/GoatTraitCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xGoatedGoatsTrait": {
                "GoatedGoatsTrait": {
                  "mainnet": {
                    "address": "0x2068315349bdfce5",
                    "contract": "GoatedGoatsTrait",
                    "fq_address": "A.0x2068315349bdfce5.GoatedGoatsTrait",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47493273
                  },
                  "testnet": {
                    "address": "0x386817f360a5c8df",
                    "contract": "GoatedGoatsTrait",
                    "fq_address": "A.0x386817f360a5c8df.GoatedGoatsTrait",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95789514
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47493285
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95789521
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47493290
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95789530
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47493295
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95789533
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47493296
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95789534
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47493297
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95789544
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "6d333bddf66461484b7c37767128dc652f21ad8698d2a2b3d80d5e7249175cd3",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a GoatedGoatsTraits NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import GoatedGoatsTrait from 0xGoatedGoatsTrait\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: GoatedGoatsTraits\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoatsTrait.Collection>(from: /storage/GoatTraitCollection) == nil {\n            let collection <- GoatedGoatsTrait.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatTraitCollection)\n        }\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/public/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/private/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/GoatTraitCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GoatTraitCollection)\n            .borrow<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@GoatedGoatsTrait.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xGoatedGoatsTrait": {
                "GoatedGoatsTrait": {
                  "mainnet": {
                    "address": "0x2068315349bdfce5",
                    "contract": "GoatedGoatsTrait",
                    "fq_address": "A.0x2068315349bdfce5.GoatedGoatsTrait",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47493231
                  },
                  "testnet": {
                    "address": "0x386817f360a5c8df",
                    "contract": "GoatedGoatsTrait",
                    "fq_address": "A.0x386817f360a5c8df.GoatedGoatsTrait",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95789463
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47493243
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95789470
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47493250
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95789480
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47493254
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95789483
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47493256
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95789484
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47493261
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95789494
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "51b1c121da67e7cde870e2d164c26fcb250c595e1e20d23340f529f3dd731f41",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support HelixAuto NFTs"
                }
              }
            },
            "cadence": "import HelixAuto from 0xHelixAuto\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: HelixAuto\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&HelixAuto.Collection>(from: /storage/HelixAutoStorageV3) == nil {\n      let collection <- HelixAuto.createEmptyCollection()\n      signer.save(<-collection, to: /storage/HelixAutoStorageV3)\n    }\n    if (signer.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3).borrow() == nil) {\n      signer.unlink(/public/HelixAutoCollectionV3)\n      signer.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3, target: /storage/HelixAutoStorageV3)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xHelixAuto": {
                "HelixAuto": {
                  "mainnet": {
                    "address": "0x92afad4cdc909ff8",
                    "contract": "HelixAuto",
                    "fq_address": "A.0x92afad4cdc909ff8.HelixAuto",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47497236
                  },
                  "testnet": {
                    "address": "0x3a3e01a9123f82e3",
                    "contract": "HelixAuto",
                    "fq_address": "A.0x3a3e01a9123f82e3.HelixAuto",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95794225
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497247
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794232
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497254
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794242
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "a7c160458e6d8711b1f6c4c3cca87c31a2921e208843885247e66be4e811106b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed HelixAuto NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import HelixAuto from 0xHelixAuto\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: HelixAuto\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HelixAuto.Collection>(from: /storage/HelixAutoStorageV3) == nil {\n            let collection <- HelixAuto.createEmptyCollection()\n            acct.save(<-collection, to: /storage/HelixAutoStorageV3)\n            }\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3).borrow() == nil) {\n            acct.unlink(/public/HelixAutoCollectionV3)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3, target: /storage/HelixAutoStorageV3)\n        }\n\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection).borrow() == nil) {\n            acct.unlink(/private/HelixAutoCollection)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection, target: /storage/HelixAutoStorageV3)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/HelixAutoStorageV3\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xHelixAuto": {
                "HelixAuto": {
                  "mainnet": {
                    "address": "0x92afad4cdc909ff8",
                    "contract": "HelixAuto",
                    "fq_address": "A.0x92afad4cdc909ff8.HelixAuto",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47497312
                  },
                  "testnet": {
                    "address": "0x3a3e01a9123f82e3",
                    "contract": "HelixAuto",
                    "fq_address": "A.0x3a3e01a9123f82e3.HelixAuto",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95794312
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497323
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794320
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497329
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794329
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47497334
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95794331
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497335
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794333
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497339
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794343
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "f0f430284f2dedf3a210f37964895d2e5e0f67870c371068d08c586719819e66",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a HelixAuto NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import HelixAuto from 0xHelixAuto\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: HelixAuto\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HelixAuto.Collection>(from: /storage/HelixAutoStorageV3) == nil {\n            let collection <- HelixAuto.createEmptyCollection()\n            acct.save(<-collection, to: /storage/HelixAutoStorageV3)\n        }\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3).borrow() == nil) {\n            acct.unlink(/public/HelixAutoCollectionV3)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3, target: /storage/HelixAutoStorageV3)\n        }\n\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection).borrow() == nil) {\n            acct.unlink(/private/HelixAutoCollection)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection, target: /storage/HelixAutoStorageV3)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/HelixAutoCollection)!\n        let collectionRef = acct\n            .getCapability(/public/HelixAutoCollectionV3)\n            .borrow<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@HelixAuto.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xHelixAuto": {
                "HelixAuto": {
                  "mainnet": {
                    "address": "0x92afad4cdc909ff8",
                    "contract": "HelixAuto",
                    "fq_address": "A.0x92afad4cdc909ff8.HelixAuto",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47497268
                  },
                  "testnet": {
                    "address": "0x3a3e01a9123f82e3",
                    "contract": "HelixAuto",
                    "fq_address": "A.0x3a3e01a9123f82e3.HelixAuto",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95794262
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497279
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794269
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497287
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794279
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47497292
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95794281
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47497294
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95794282
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47497299
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95794292
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "2219c917eb9e3c9671deea0bf9c014aaeac082c5eb416e80238aaa52d303603c",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support JollyJokers NFTs"
                }
              }
            },
            "cadence": "import JollyJokers from 0xJollyJokers\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: JollyJokers\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&JollyJokers.Collection>(from: /storage/JollyJokersCollection) == nil {\n      let collection <- JollyJokers.createEmptyCollection()\n      signer.save(<-collection, to: /storage/JollyJokersCollection)\n    }\n    if (signer.getCapability<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection).borrow() == nil) {\n      signer.unlink(/public/JollyJokersCollection)\n      signer.link<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection, target: /storage/JollyJokersCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xJollyJokers": {
                "JollyJokers": {
                  "mainnet": {
                    "address": "0x699bf284101a76f1",
                    "contract": "JollyJokers",
                    "fq_address": "A.0x699bf284101a76f1.JollyJokers",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47506718
                  },
                  "testnet": {
                    "address": "0xe9760069d688ef5e",
                    "contract": "JollyJokers",
                    "fq_address": "A.0xe9760069d688ef5e.JollyJokers",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95805517
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506730
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805525
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506735
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805534
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "db57a7ad6c8de429f6f3bcc6daa4c0040a91432066bdd06948d25ca9625922c8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed JollyJokers NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import JollyJokers from 0xJollyJokers\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: JollyJokers\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&JollyJokers.Collection>(from: /storage/JollyJokersCollection) == nil {\n            let collection <- JollyJokers.createEmptyCollection()\n            acct.save(<-collection, to: /storage/JollyJokersCollection)\n            }\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection).borrow() == nil) {\n            acct.unlink(/public/JollyJokersCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection, target: /storage/JollyJokersCollection)\n        }\n\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection).borrow() == nil) {\n            acct.unlink(/private/findCharityCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection, target: /storage/JollyJokersCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/JollyJokersCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xJollyJokers": {
                "JollyJokers": {
                  "mainnet": {
                    "address": "0x699bf284101a76f1",
                    "contract": "JollyJokers",
                    "fq_address": "A.0x699bf284101a76f1.JollyJokers",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47506789
                  },
                  "testnet": {
                    "address": "0xe9760069d688ef5e",
                    "contract": "JollyJokers",
                    "fq_address": "A.0xe9760069d688ef5e.JollyJokers",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95805604
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506800
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805611
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506808
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805620
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506813
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95805623
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506814
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805624
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506819
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805633
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0779a76f27ee9aa655f9f5c0856d3344c3cbd4117af20d453d35234d42f46bb5",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a JollyJokers NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import JollyJokers from 0xJollyJokers\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: JollyJokers\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&JollyJokers.Collection>(from: /storage/JollyJokersCollection) == nil {\n            let collection <- JollyJokers.createEmptyCollection()\n            acct.save(<-collection, to: /storage/JollyJokersCollection)\n        }\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection).borrow() == nil) {\n            acct.unlink(/public/JollyJokersCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection, target: /storage/JollyJokersCollection)\n        }\n\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection).borrow() == nil) {\n            acct.unlink(/private/findCharityCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection, target: /storage/JollyJokersCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/findCharityCollection)!\n        let collectionRef = acct\n            .getCapability(/public/JollyJokersCollection)\n            .borrow<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@JollyJokers.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xJollyJokers": {
                "JollyJokers": {
                  "mainnet": {
                    "address": "0x699bf284101a76f1",
                    "contract": "JollyJokers",
                    "fq_address": "A.0x699bf284101a76f1.JollyJokers",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47506748
                  },
                  "testnet": {
                    "address": "0xe9760069d688ef5e",
                    "contract": "JollyJokers",
                    "fq_address": "A.0xe9760069d688ef5e.JollyJokers",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95805554
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506759
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805561
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506766
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805571
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506772
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95805573
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506772
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805574
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506778
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805584
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "95987f8a699d615a651506ad8f5095816a4c3f8b27006963a3b9a5ccc61d1cdc",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support KlktnVoucher NFTs"
                }
              }
            },
            "cadence": "import KlktnVoucher from 0xKlktnVoucher\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: KlktnVoucher\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&KlktnVoucher.Collection>(from: /storage/KlktnVoucherCollection) == nil {\n      let collection <- KlktnVoucher.createEmptyCollection()\n      signer.save(<-collection, to: /storage/KlktnVoucherCollection)\n    }\n    if (signer.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection).borrow() == nil) {\n      signer.unlink(/public/KlktnVoucherCollection)\n      signer.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection, target: /storage/KlktnVoucherCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xKlktnVoucher": {
                "KlktnVoucher": {
                  "testnet": {
                    "address": "0x21344d9b7e93ade6",
                    "contract": "KlktnVoucher",
                    "fq_address": "A.0x21344d9b7e93ade6.KlktnVoucher",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813643
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813647
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813652
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "50aeed3774085d8939c7e36d004375ea14947a9507bbfc30c11c180e1f6201b2",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed KlktnVoucher NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import KlktnVoucher from 0xKlktnVoucher\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: KlktnVoucher\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&KlktnVoucher.Collection>(from: /storage/KlktnVoucherCollection) == nil {\n            let collection <- KlktnVoucher.createEmptyCollection()\n            acct.save(<-collection, to: /storage/KlktnVoucherCollection)\n            }\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection).borrow() == nil) {\n            acct.unlink(/public/KlktnVoucherCollection)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection, target: /storage/KlktnVoucherCollection)\n        }\n\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/KlktnVoucherPrivateProvider)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider, target: /storage/KlktnVoucherCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/KlktnVoucherCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xKlktnVoucher": {
                "KlktnVoucher": {
                  "testnet": {
                    "address": "0x21344d9b7e93ade6",
                    "contract": "KlktnVoucher",
                    "fq_address": "A.0x21344d9b7e93ade6.KlktnVoucher",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813686
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813689
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813694
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813695
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813695
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813700
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "407fba5a79f20fc934c0c574bb0db1c82f520b60f0d95eaa035f9c51fcb33d41",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a KlktnVoucher NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import KlktnVoucher from 0xKlktnVoucher\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: KlktnVoucher\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&KlktnVoucher.Collection>(from: /storage/KlktnVoucherCollection) == nil {\n            let collection <- KlktnVoucher.createEmptyCollection()\n            acct.save(<-collection, to: /storage/KlktnVoucherCollection)\n        }\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection).borrow() == nil) {\n            acct.unlink(/public/KlktnVoucherCollection)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection, target: /storage/KlktnVoucherCollection)\n        }\n\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/KlktnVoucherPrivateProvider)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider, target: /storage/KlktnVoucherCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/KlktnVoucherPrivateProvider)!\n        let collectionRef = acct\n            .getCapability(/public/KlktnVoucherCollection)\n            .borrow<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@KlktnVoucher.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xKlktnVoucher": {
                "KlktnVoucher": {
                  "testnet": {
                    "address": "0x21344d9b7e93ade6",
                    "contract": "KlktnVoucher",
                    "fq_address": "A.0x21344d9b7e93ade6.KlktnVoucher",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813661
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813665
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813669
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813670
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813671
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813676
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "9f441aeb0c523a95d60968352be09229a9421a6ab0ade24a128d12a80a520f00",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support LaligaGolazos NFTs"
                }
              }
            },
            "cadence": "import Golazos from 0xGolazos\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: LaligaGolazos\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Golazos.Collection>(from: /storage/GolazosNFTCollection) == nil {\n      let collection <- Golazos.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GolazosNFTCollection)\n    }\n    if (signer.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection).borrow() == nil) {\n      signer.unlink(/public/GolazosNFTCollection)\n      signer.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection, target: /storage/GolazosNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xGolazos": {
                "Golazos": {
                  "mainnet": {
                    "address": "0x87ca73a41bb50ad5",
                    "contract": "Golazos",
                    "fq_address": "A.0x87ca73a41bb50ad5.Golazos",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47507483
                  },
                  "testnet": {
                    "address": "0x1271da8a94edb0ff",
                    "contract": "Golazos",
                    "fq_address": "A.0x1271da8a94edb0ff.Golazos",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95806425
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507496
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806431
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507503
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806441
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "46fe37e59e85e80f0a83d92e16c3e0f631e3fc5584d4a48b342c7605d5e6a8e7",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed LaligaGolazos NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Golazos from 0xGolazos\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: LaligaGolazos\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Golazos.Collection>(from: /storage/GolazosNFTCollection) == nil {\n            let collection <- Golazos.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GolazosNFTCollection)\n            }\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection).borrow() == nil) {\n            acct.unlink(/public/GolazosNFTCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection, target: /storage/GolazosNFTCollection)\n        }\n\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection).borrow() == nil) {\n            acct.unlink(/private/dapperSportCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection, target: /storage/GolazosNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/GolazosNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xGolazos": {
                "Golazos": {
                  "mainnet": {
                    "address": "0x87ca73a41bb50ad5",
                    "contract": "Golazos",
                    "fq_address": "A.0x87ca73a41bb50ad5.Golazos",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47507560
                  },
                  "testnet": {
                    "address": "0x1271da8a94edb0ff",
                    "contract": "Golazos",
                    "fq_address": "A.0x1271da8a94edb0ff.Golazos",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95806510
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507571
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806516
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507578
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806526
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507583
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95806528
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507586
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806529
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507589
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806540
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "03c79a8c2ca57a86d9864af9fd0fd205f0f046f7d91524890db206f56ce2fba6",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a LaligaGolazos NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Golazos from 0xGolazos\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: LaligaGolazos\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Golazos.Collection>(from: /storage/GolazosNFTCollection) == nil {\n            let collection <- Golazos.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GolazosNFTCollection)\n        }\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection).borrow() == nil) {\n            acct.unlink(/public/GolazosNFTCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection, target: /storage/GolazosNFTCollection)\n        }\n\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection).borrow() == nil) {\n            acct.unlink(/private/dapperSportCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection, target: /storage/GolazosNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/dapperSportCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GolazosNFTCollection)\n            .borrow<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Golazos.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xGolazos": {
                "Golazos": {
                  "mainnet": {
                    "address": "0x87ca73a41bb50ad5",
                    "contract": "Golazos",
                    "fq_address": "A.0x87ca73a41bb50ad5.Golazos",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47507516
                  },
                  "testnet": {
                    "address": "0x1271da8a94edb0ff",
                    "contract": "Golazos",
                    "fq_address": "A.0x1271da8a94edb0ff.Golazos",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95806461
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507528
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806467
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507537
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806476
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507541
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95806479
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507541
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806480
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507545
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806489
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "cd709b9b6e84e0c3e1e06d9f9a9fe9157d15378012aa449a367aaf64305041e7",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Metabilia NFTs"
                }
              }
            },
            "cadence": "import MetabiliaNFT from 0xMetabiliaNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Metabilia\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MetabiliaNFT.Collection>(from: /storage/MetabiliaNFTCollection) == nil {\n      let collection <- MetabiliaNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MetabiliaNFTCollection)\n    }\n    if (signer.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection).borrow() == nil) {\n      signer.unlink(/public/MetabiliaNFTCollection)\n      signer.link<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMetabiliaNFT": {
                "MetabiliaNFT": {
                  "testnet": {
                    "address": "0x5bfb52a5bf7d2da5",
                    "contract": "MetabiliaNFT",
                    "fq_address": "A.0x5bfb52a5bf7d2da5.MetabiliaNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95813570
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813574
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813578
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "1d881512b121d6f6c62cbaaa8bad35985f8ada8ad679f4502c54d2e2a2b71580",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Metabilia NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MetabiliaNFT from 0xMetabiliaNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Metabilia\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MetabiliaNFT.Collection>(from: /storage/MetabiliaNFTCollection) == nil {\n            let collection <- MetabiliaNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MetabiliaNFTCollection)\n            }\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/public/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/private/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MetabiliaNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMetabiliaNFT": {
                "MetabiliaNFT": {
                  "testnet": {
                    "address": "0x5bfb52a5bf7d2da5",
                    "contract": "MetabiliaNFT",
                    "fq_address": "A.0x5bfb52a5bf7d2da5.MetabiliaNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95813613
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813617
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813622
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813623
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813623
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813628
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "f030b11093b1b92f93c0c84ace648826dd2d2f1bc964ff2a8981bde21bb5b910",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Metabilia NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MetabiliaNFT from 0xMetabiliaNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Metabilia\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MetabiliaNFT.Collection>(from: /storage/MetabiliaNFTCollection) == nil {\n            let collection <- MetabiliaNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MetabiliaNFTCollection)\n        }\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/public/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/private/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MetabiliaNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MetabiliaNFTCollection)\n            .borrow<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MetabiliaNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMetabiliaNFT": {
                "MetabiliaNFT": {
                  "testnet": {
                    "address": "0x5bfb52a5bf7d2da5",
                    "contract": "MetabiliaNFT",
                    "fq_address": "A.0x5bfb52a5bf7d2da5.MetabiliaNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95813588
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813592
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813597
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813598
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813599
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813603
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "d63b8d3546d364f8f5c05471062c82ac31d75ec477de0b17b55f3852aa0fcad1",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support MFLPackCollection NFTs"
                }
              }
            },
            "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MFLPackCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n      let collection <- MFLPack.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MFLPackCollection)\n    }\n    if (signer.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n      signer.unlink(/public/MFLPackCollection)\n      signer.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMFLPack": {
                "MFLPack": {
                  "testnet": {
                    "address": "0x683564e46977788a",
                    "contract": "MFLPack",
                    "fq_address": "A.0x683564e46977788a.MFLPack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95813486
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813490
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813495
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "44811b552c08310fe45d7b2fe6ae2a441a261e33e7b5855cd15646f1b1c44253",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed MFLPackCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MFLPackCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n            let collection <- MFLPack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPackCollection)\n            }\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MFLPackCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMFLPack": {
                "MFLPack": {
                  "testnet": {
                    "address": "0x683564e46977788a",
                    "contract": "MFLPack",
                    "fq_address": "A.0x683564e46977788a.MFLPack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95813541
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813544
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813548
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813549
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813550
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813554
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "be56510943b2a3b893a6b5c069844a0f030c5f741aba06b0171c5b6ff41addbb",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a MFLPackCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MFLPackCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n            let collection <- MFLPack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPackCollection)\n        }\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MFLPackCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MFLPackCollection)\n            .borrow<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MFLPack.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMFLPack": {
                "MFLPack": {
                  "testnet": {
                    "address": "0x683564e46977788a",
                    "contract": "MFLPack",
                    "fq_address": "A.0x683564e46977788a.MFLPack",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95813510
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813514
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813518
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813519
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813520
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813525
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "6b5b5f783a3afe5dec1a621fabd4c76656a8dc4a5f4f765b1bb04297674d11c0",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Mindtrix NFTs"
                }
              }
            },
            "cadence": "import Mindtrix from 0xMindtrix\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Mindtrix\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Mindtrix.Collection>(from: /storage/MindtrixNFTCollection) == nil {\n      let collection <- Mindtrix.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MindtrixNFTCollection)\n    }\n    if (signer.getCapability<&Mindtrix.Collection{Mindtrix.MindtrixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MindtrixNFTCollection).borrow() == nil) {\n      signer.unlink(/public/MindtrixNFTCollection)\n      signer.link<&Mindtrix.Collection{Mindtrix.MindtrixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MindtrixNFTCollection, target: /storage/MindtrixNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMindtrix": {
                "Mindtrix": {
                  "mainnet": {
                    "address": "0x74266bc086680e5e",
                    "contract": "Mindtrix",
                    "fq_address": "A.0x74266bc086680e5e.Mindtrix",
                    "pin": "ff354108762eba4ffce22fe6a264fe6840d4b0c45f52157d9d1c98540f4b8469",
                    "pin_block_height": 47509776
                  },
                  "testnet": {
                    "address": "0xd162b02676d63c36",
                    "contract": "Mindtrix",
                    "fq_address": "A.0xd162b02676d63c36.Mindtrix",
                    "pin": "ff354108762eba4ffce22fe6a264fe6840d4b0c45f52157d9d1c98540f4b8469",
                    "pin_block_height": 95809165
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509811
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809173
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509819
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809182
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "639c9c5279c92f905efc43d1838461d16cfa73939c71ecbac7880bca005b095f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Momentables NFTs"
                }
              }
            },
            "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Momentables\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n      let collection <- Momentables.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MomentablesCollection)\n    }\n    if (signer.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n      signer.unlink(/public/MomentablesCollection)\n      signer.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMomentables": {
                "Momentables": {
                  "mainnet": {
                    "address": "0x9d21537544d9123d",
                    "contract": "Momentables",
                    "fq_address": "A.0x9d21537544d9123d.Momentables",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47508722
                  },
                  "testnet": {
                    "address": "0x9f2eb43b6df02730",
                    "contract": "Momentables",
                    "fq_address": "A.0x9f2eb43b6df02730.Momentables",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95807883
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508732
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807890
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508739
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807900
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "88984e1873c28dc8f0300fdd134ac1b01df307aca14f138a1962f164d5b5368c",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Momentables NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Momentables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n            let collection <- Momentables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentablesCollection)\n            }\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n            acct.unlink(/public/MomentablesCollection)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n        }\n\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/MomentablesCollectionProvider)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider, target: /storage/MomentablesCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MomentablesCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMomentables": {
                "Momentables": {
                  "mainnet": {
                    "address": "0x9d21537544d9123d",
                    "contract": "Momentables",
                    "fq_address": "A.0x9d21537544d9123d.Momentables",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47508794
                  },
                  "testnet": {
                    "address": "0x9f2eb43b6df02730",
                    "contract": "Momentables",
                    "fq_address": "A.0x9f2eb43b6df02730.Momentables",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95807970
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508804
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807977
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508812
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807987
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47508816
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95807990
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508817
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807991
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508823
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808001
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0088fc9ef4ab5af1d0d280f80cf00b2aff856c5ca950cd77bf47c69a600bb0e8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Momentables NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Momentables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n            let collection <- Momentables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentablesCollection)\n        }\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n            acct.unlink(/public/MomentablesCollection)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n        }\n\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/MomentablesCollectionProvider)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider, target: /storage/MomentablesCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MomentablesCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/MomentablesCollection)\n            .borrow<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Momentables.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMomentables": {
                "Momentables": {
                  "mainnet": {
                    "address": "0x9d21537544d9123d",
                    "contract": "Momentables",
                    "fq_address": "A.0x9d21537544d9123d.Momentables",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47508752
                  },
                  "testnet": {
                    "address": "0x9f2eb43b6df02730",
                    "contract": "Momentables",
                    "fq_address": "A.0x9f2eb43b6df02730.Momentables",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95807921
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508762
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807928
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508771
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807938
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47508775
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95807940
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508777
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807941
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508781
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807951
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "4076d0693fcc859a3048c151cacc54c17fe4d7665da832ec2830a85735fd1a57",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support MonoCats NFTs"
                }
              }
            },
            "cadence": "import MonoCat from 0xMonoCat\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MonoCats\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MonoCat.Collection>(from: /storage/MonoCatCollection) == nil {\n      let collection <- MonoCat.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MonoCatCollection)\n    }\n    if (signer.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection).borrow() == nil) {\n      signer.unlink(/public/MonoCatCollection)\n      signer.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection, target: /storage/MonoCatCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMonoCat": {
                "MonoCat": {
                  "mainnet": {
                    "address": "0x8529aaf64c168952",
                    "contract": "MonoCat",
                    "fq_address": "A.0x8529aaf64c168952.MonoCat",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499586
                  },
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCat",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCat",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797028
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499599
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797035
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499607
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797044
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "8b1f803d29a113307911860eca44ff98ff46179e05e27c09a2a9eaa8eb1ca323",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed MonoCats NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MonoCat from 0xMonoCat\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MonoCats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCat.Collection>(from: /storage/MonoCatCollection) == nil {\n            let collection <- MonoCat.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatCollection)\n            }\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MonoCatCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMonoCat": {
                "MonoCat": {
                  "mainnet": {
                    "address": "0x8529aaf64c168952",
                    "contract": "MonoCat",
                    "fq_address": "A.0x8529aaf64c168952.MonoCat",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499660
                  },
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCat",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCat",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797114
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499671
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797121
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499680
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797130
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499684
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95797133
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499686
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797134
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499691
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797143
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "47d4499101de5ccdbd9b8018c0103008e320c100c8da36f6fba984297f12d7f7",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a MonoCats NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MonoCat from 0xMonoCat\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCat.Collection>(from: /storage/MonoCatCollection) == nil {\n            let collection <- MonoCat.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatCollection)\n        }\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MonoCatCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MonoCatCollection)\n            .borrow<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MonoCat.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMonoCat": {
                "MonoCat": {
                  "mainnet": {
                    "address": "0x8529aaf64c168952",
                    "contract": "MonoCat",
                    "fq_address": "A.0x8529aaf64c168952.MonoCat",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47499619
                  },
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCat",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCat",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95797064
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499631
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797071
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499639
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797080
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499643
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95797083
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499643
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95797084
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499649
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95797093
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "9e3e66dabc4e7e3a32b5a9933c2aa3d44f9225e5a12cea2c13614440c39764d7",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support MonoCatsGachapon NFTs"
                }
              }
            },
            "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MonoCatsGachapon\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n      let collection <- MonoCatMysteryBox.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n    }\n    if (signer.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n      signer.unlink(/public/MonoCatMysteryBoxCollection)\n      signer.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMonoCatMysteryBox": {
                "MonoCatMysteryBox": {
                  "mainnet": {
                    "address": "0x8529aaf64c168952",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0x8529aaf64c168952.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47501452
                  },
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95799251
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501464
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799259
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501470
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799268
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7436fc259e80beca62f7496fe272924eaf34fbf51146b46a02bd327ae92e772f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed MonoCatsGachapon NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MonoCatsGachapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n            }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MonoCatMysteryBoxCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMonoCatMysteryBox": {
                "MonoCatMysteryBox": {
                  "mainnet": {
                    "address": "0x8529aaf64c168952",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0x8529aaf64c168952.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47501525
                  },
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95799336
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501537
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799343
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501544
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799353
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47501548
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95799355
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501548
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799356
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501554
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799366
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "25f115e87092b67e3b0c435159d73fc95df5d5ce4e7a348b587a16bdb1894ba6",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a MonoCatsGachapon NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCatsGachapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n        }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MonoCatMysteryBoxCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MonoCatMysteryBoxCollection)\n            .borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MonoCatMysteryBox.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMonoCatMysteryBox": {
                "MonoCatMysteryBox": {
                  "mainnet": {
                    "address": "0x8529aaf64c168952",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0x8529aaf64c168952.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47501482
                  },
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95799287
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501493
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799294
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501501
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799303
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47501507
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95799305
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501509
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799307
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501513
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799317
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "14105e31ee41106931a9f96134673d510ca3f0703219c03b9f79cab65608b89c",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support MonoCatsGashapon NFTs"
                }
              }
            },
            "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MonoCatsGashapon\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n      let collection <- MonoCatMysteryBox.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n    }\n    if (signer.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n      signer.unlink(/public/MonoCatMysteryBoxCollection)\n      signer.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMonoCatMysteryBox": {
                "MonoCatMysteryBox": {
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95814017
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95814021
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95814026
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "4ce3de22f218a491526db8005a1c1ae090d4bd4566854016bb25831be645556b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed MonoCatsGashapon NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MonoCatsGashapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n            }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MonoCatMysteryBoxCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMonoCatMysteryBox": {
                "MonoCatMysteryBox": {
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95814062
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95814066
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95814071
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95814071
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95814072
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95814077
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "fa361ad78b90e3458c72cb67395a00f646a35716f4ac3383b59d637c15d4c2ec",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a MonoCatsGashapon NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCatsGashapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n        }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MonoCatMysteryBoxCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MonoCatMysteryBoxCollection)\n            .borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MonoCatMysteryBox.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMonoCatMysteryBox": {
                "MonoCatMysteryBox": {
                  "testnet": {
                    "address": "0xa01dd6e82b7352be",
                    "contract": "MonoCatMysteryBox",
                    "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95814037
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95814040
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95814045
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95814046
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95814047
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95814052
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "1f8dc27f12a2a38d60a0c35354a1bef8d25eea72d69132e4a796b7ccfc48f1b6",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support MusicPeaksAttendanceToken NFTs"
                }
              }
            },
            "cadence": "import MusicPeaksAttendanceToken from 0xMusicPeaksAttendanceToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MusicPeaksAttendanceToken\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MusicPeaksAttendanceToken.Collection>(from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath) == nil {\n      let collection <- MusicPeaksAttendanceToken.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n    }\n    if (signer.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath).borrow() == nil) {\n      signer.unlink(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n      signer.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMusicPeaksAttendanceToken": {
                "MusicPeaksAttendanceToken": {
                  "mainnet": {
                    "address": "0xc467cbdf44afa9eb",
                    "contract": "MusicPeaksAttendanceToken",
                    "fq_address": "A.0xc467cbdf44afa9eb.MusicPeaksAttendanceToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47508537
                  },
                  "testnet": {
                    "address": "0x644ee69fccf4ab48",
                    "contract": "MusicPeaksAttendanceToken",
                    "fq_address": "A.0x644ee69fccf4ab48.MusicPeaksAttendanceToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95807677
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508556
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807684
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508564
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807693
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "b6b93431b57d12e5c8b41160e1aa54669f5f654ffc3f2f776e88c0f9541cf7c2",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed MusicPeaksAttendanceToken NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MusicPeaksAttendanceToken from 0xMusicPeaksAttendanceToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MusicPeaksAttendanceToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksAttendanceToken.Collection>(from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksAttendanceToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n            }\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksAttendanceTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMusicPeaksAttendanceToken": {
                "MusicPeaksAttendanceToken": {
                  "mainnet": {
                    "address": "0xc467cbdf44afa9eb",
                    "contract": "MusicPeaksAttendanceToken",
                    "fq_address": "A.0xc467cbdf44afa9eb.MusicPeaksAttendanceToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47508644
                  },
                  "testnet": {
                    "address": "0x644ee69fccf4ab48",
                    "contract": "MusicPeaksAttendanceToken",
                    "fq_address": "A.0x644ee69fccf4ab48.MusicPeaksAttendanceToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95807801
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508664
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807809
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508672
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807819
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47508675
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95807821
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508677
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807822
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508682
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807832
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "6a8da986f1e321618e1339ff2d485f7e2a7e14a81dcbeae6380173e3955f9392",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a MusicPeaksAttendanceToken NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MusicPeaksAttendanceToken from 0xMusicPeaksAttendanceToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksAttendanceToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksAttendanceToken.Collection>(from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksAttendanceToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksAttendanceTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath)!\n        let collectionRef = acct\n            .getCapability(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n            .borrow<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MusicPeaksAttendanceToken.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMusicPeaksAttendanceToken": {
                "MusicPeaksAttendanceToken": {
                  "mainnet": {
                    "address": "0xc467cbdf44afa9eb",
                    "contract": "MusicPeaksAttendanceToken",
                    "fq_address": "A.0xc467cbdf44afa9eb.MusicPeaksAttendanceToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47508583
                  },
                  "testnet": {
                    "address": "0x644ee69fccf4ab48",
                    "contract": "MusicPeaksAttendanceToken",
                    "fq_address": "A.0x644ee69fccf4ab48.MusicPeaksAttendanceToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95807734
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508604
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807741
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508611
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807750
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47508617
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95807753
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508617
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95807754
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508622
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95807763
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "2c3fbf6e26fae54df67f652577332e44748747528e8cdb3599135ff3597ccb94",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support MusicPeaksMembershipToken NFTs"
                }
              }
            },
            "cadence": "import MusicPeaksMembershipToken from 0xMusicPeaksMembershipToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MusicPeaksMembershipToken\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MusicPeaksMembershipToken.Collection>(from: /storage/MusicPeaksMembershipTokenCollectionStoragePath) == nil {\n      let collection <- MusicPeaksMembershipToken.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n    }\n    if (signer.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath).borrow() == nil) {\n      signer.unlink(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n      signer.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMusicPeaksMembershipToken": {
                "MusicPeaksMembershipToken": {
                  "mainnet": {
                    "address": "0xa02c28dc0aa50c18",
                    "contract": "MusicPeaksMembershipToken",
                    "fq_address": "A.0xa02c28dc0aa50c18.MusicPeaksMembershipToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47503061
                  },
                  "testnet": {
                    "address": "0x860aded18da159c0",
                    "contract": "MusicPeaksMembershipToken",
                    "fq_address": "A.0x860aded18da159c0.MusicPeaksMembershipToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95801152
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47503081
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801159
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47503088
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801169
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "8503a59ab8dd1a3ef7e9b23dbdd62e5c9fd74cba61ee970b9823a72e20cbf85a",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed MusicPeaksMembershipToken NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MusicPeaksMembershipToken from 0xMusicPeaksMembershipToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MusicPeaksMembershipToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksMembershipToken.Collection>(from: /storage/MusicPeaksMembershipTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksMembershipToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n            }\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksMembershipTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MusicPeaksMembershipTokenCollectionStoragePath\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMusicPeaksMembershipToken": {
                "MusicPeaksMembershipToken": {
                  "mainnet": {
                    "address": "0xa02c28dc0aa50c18",
                    "contract": "MusicPeaksMembershipToken",
                    "fq_address": "A.0xa02c28dc0aa50c18.MusicPeaksMembershipToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47503165
                  },
                  "testnet": {
                    "address": "0x860aded18da159c0",
                    "contract": "MusicPeaksMembershipToken",
                    "fq_address": "A.0x860aded18da159c0.MusicPeaksMembershipToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95801277
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47503181
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801284
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47503188
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801294
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47503193
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95801296
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47503196
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801297
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47503201
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801307
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0f0c5e7acd2a0dd4f8fbff660b8ea9130922dc4f4c80f34d7f09966a22ccd1a1",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a MusicPeaksMembershipToken NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MusicPeaksMembershipToken from 0xMusicPeaksMembershipToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksMembershipToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksMembershipToken.Collection>(from: /storage/MusicPeaksMembershipTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksMembershipToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksMembershipTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath)!\n        let collectionRef = acct\n            .getCapability(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n            .borrow<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MusicPeaksMembershipToken.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMusicPeaksMembershipToken": {
                "MusicPeaksMembershipToken": {
                  "mainnet": {
                    "address": "0xa02c28dc0aa50c18",
                    "contract": "MusicPeaksMembershipToken",
                    "fq_address": "A.0xa02c28dc0aa50c18.MusicPeaksMembershipToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47503108
                  },
                  "testnet": {
                    "address": "0x860aded18da159c0",
                    "contract": "MusicPeaksMembershipToken",
                    "fq_address": "A.0x860aded18da159c0.MusicPeaksMembershipToken",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95801209
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47503125
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801216
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47503132
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801226
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47503137
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95801228
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47503138
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801229
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47503143
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801239
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "8f192a46815fa7c20d86197197c3896d90c52b1785b316f542fbecfebdbe5d5c",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support MusicPeaksVideoNFT NFTs"
                }
              }
            },
            "cadence": "import MusicPeaksVideoNFT from 0xMusicPeaksVideoNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MusicPeaksVideoNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MusicPeaksVideoNFT.Collection>(from: /storage/MusicPeaksVideoCollection) == nil {\n      let collection <- MusicPeaksVideoNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MusicPeaksVideoCollection)\n    }\n    if (signer.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection).borrow() == nil) {\n      signer.unlink(/public/MusicPeaksVideoCollection)\n      signer.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xMusicPeaksVideoNFT": {
                "MusicPeaksVideoNFT": {
                  "mainnet": {
                    "address": "0xd5c1f9ff20308c59",
                    "contract": "MusicPeaksVideoNFT",
                    "fq_address": "A.0xd5c1f9ff20308c59.MusicPeaksVideoNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505360
                  },
                  "testnet": {
                    "address": "0x171d2aeb325e6e3e",
                    "contract": "MusicPeaksVideoNFT",
                    "fq_address": "A.0x171d2aeb325e6e3e.MusicPeaksVideoNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95803885
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505368
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803892
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505375
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803901
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "309fc978c3889b09647d1580e83c35d8390a15e773d0f3e02d4084f71c23c730",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed MusicPeaksVideoNFT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MusicPeaksVideoNFT from 0xMusicPeaksVideoNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MusicPeaksVideoNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksVideoNFT.Collection>(from: /storage/MusicPeaksVideoCollection) == nil {\n            let collection <- MusicPeaksVideoNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksVideoCollection)\n            }\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MusicPeaksVideoCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xMusicPeaksVideoNFT": {
                "MusicPeaksVideoNFT": {
                  "mainnet": {
                    "address": "0xd5c1f9ff20308c59",
                    "contract": "MusicPeaksVideoNFT",
                    "fq_address": "A.0xd5c1f9ff20308c59.MusicPeaksVideoNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505429
                  },
                  "testnet": {
                    "address": "0x171d2aeb325e6e3e",
                    "contract": "MusicPeaksVideoNFT",
                    "fq_address": "A.0x171d2aeb325e6e3e.MusicPeaksVideoNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95803970
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505441
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803977
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505448
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803987
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505454
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95803990
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505455
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803991
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505459
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804000
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "1142e463dd6bf8ae35a6e2de77b4d37fd4e2e4cdeb499a239b90c3615508907e",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a MusicPeaksVideoNFT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import MusicPeaksVideoNFT from 0xMusicPeaksVideoNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksVideoNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksVideoNFT.Collection>(from: /storage/MusicPeaksVideoCollection) == nil {\n            let collection <- MusicPeaksVideoNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksVideoCollection)\n        }\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MusicPeaksVideoCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MusicPeaksVideoCollection)\n            .borrow<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MusicPeaksVideoNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xMusicPeaksVideoNFT": {
                "MusicPeaksVideoNFT": {
                  "mainnet": {
                    "address": "0xd5c1f9ff20308c59",
                    "contract": "MusicPeaksVideoNFT",
                    "fq_address": "A.0xd5c1f9ff20308c59.MusicPeaksVideoNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505389
                  },
                  "testnet": {
                    "address": "0x171d2aeb325e6e3e",
                    "contract": "MusicPeaksVideoNFT",
                    "fq_address": "A.0x171d2aeb325e6e3e.MusicPeaksVideoNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95803920
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505398
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803928
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505405
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803937
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505412
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95803940
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505413
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95803941
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505417
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95803950
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ec10e6483f820623ab30d61d6c2757768a4565edd550150ab8403a1abfd524ec",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support NBATopShot NFTs"
                }
              }
            },
            "cadence": "import TopShot from 0xTopShot\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NBATopShot\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n      let collection <- TopShot.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MomentCollection)\n    }\n    if (signer.getCapability<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection).borrow() == nil) {\n      signer.unlink(/public/MomentCollection)\n      signer.link<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection, target: /storage/MomentCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xTopShot": {
                "TopShot": {
                  "mainnet": {
                    "address": "0x0b2a3299cc857e29",
                    "contract": "TopShot",
                    "fq_address": "A.0x0b2a3299cc857e29.TopShot",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47489322
                  },
                  "testnet": {
                    "address": "0x877931736ee77cff",
                    "contract": "TopShot",
                    "fq_address": "A.0x877931736ee77cff.TopShot",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95784868
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489337
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784875
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489344
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784884
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7257721c003c8d3088fd8f4816bc25989575afed88349fe106e594f72aec5ff3",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed NBATopShot NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TopShot from 0xTopShot\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NBATopShot\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n            let collection <- TopShot.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentCollection)\n            }\n        if (acct.getCapability<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection).borrow() == nil) {\n            acct.unlink(/public/MomentCollection)\n            acct.link<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        if (acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection).borrow() == nil) {\n            acct.unlink(/private/MomentCollection)\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection, target: /storage/MomentCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MomentCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xTopShot": {
                "TopShot": {
                  "mainnet": {
                    "address": "0x0b2a3299cc857e29",
                    "contract": "TopShot",
                    "fq_address": "A.0x0b2a3299cc857e29.TopShot",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47489413
                  },
                  "testnet": {
                    "address": "0x877931736ee77cff",
                    "contract": "TopShot",
                    "fq_address": "A.0x877931736ee77cff.TopShot",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95784974
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489428
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784982
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489435
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784990
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47489441
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95784992
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489441
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784993
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489447
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95785003
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "4abab5444510fafbb31484a1244bd005de39102e2f18e826a27ec86e503993fa",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a NBATopShot NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TopShot from 0xTopShot\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NBATopShot\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n            let collection <- TopShot.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentCollection)\n        }\n        if (acct.getCapability<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection).borrow() == nil) {\n            acct.unlink(/public/MomentCollection)\n            acct.link<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        if (acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection).borrow() == nil) {\n            acct.unlink(/private/MomentCollection)\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MomentCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MomentCollection)\n            .borrow<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TopShot.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xTopShot": {
                "TopShot": {
                  "mainnet": {
                    "address": "0x0b2a3299cc857e29",
                    "contract": "TopShot",
                    "fq_address": "A.0x0b2a3299cc857e29.TopShot",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47489361
                  },
                  "testnet": {
                    "address": "0x877931736ee77cff",
                    "contract": "TopShot",
                    "fq_address": "A.0x877931736ee77cff.TopShot",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95784914
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489377
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784921
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489385
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784931
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47489390
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95784934
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489391
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784935
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489396
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784944
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "4dbde75ecd624076a49e27afcc9f6992e4e0c44dfecd6c24bba5690a81108b59",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support NBATopShotInArena NFTs"
                }
              }
            },
            "cadence": "import NBATopShotArena from 0xNBATopShotArena\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NBATopShotInArena\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&NBATopShotArena.Collection>(from: /storage/NBATopShotArena_Collection) == nil {\n      let collection <- NBATopShotArena.createEmptyCollection()\n      signer.save(<-collection, to: /storage/NBATopShotArena_Collection)\n    }\n    if (signer.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection).borrow() == nil) {\n      signer.unlink(/public/NBATopShotArena_Collection)\n      signer.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xNBATopShotArena": {
                "NBATopShotArena": {
                  "mainnet": {
                    "address": "0x27ece19eff91bab0",
                    "contract": "NBATopShotArena",
                    "fq_address": "A.0x27ece19eff91bab0.NBATopShotArena",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 47488361
                  },
                  "testnet": {
                    "address": "0x6ad6a8246cec9822",
                    "contract": "NBATopShotArena",
                    "fq_address": "A.0x6ad6a8246cec9822.NBATopShotArena",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 95783731
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488378
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783738
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488384
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783748
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0fa324eef9b8d9053e7251452dbc260f56f4886dedd00b2695337454971f802d",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed NBATopShotInArena NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import NBATopShotArena from 0xNBATopShotArena\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NBATopShotInArena\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NBATopShotArena.Collection>(from: /storage/NBATopShotArena_Collection) == nil {\n            let collection <- NBATopShotArena.createEmptyCollection()\n            acct.save(<-collection, to: /storage/NBATopShotArena_Collection)\n            }\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/public/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/private/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/NBATopShotArena_Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xNBATopShotArena": {
                "NBATopShotArena": {
                  "mainnet": {
                    "address": "0x27ece19eff91bab0",
                    "contract": "NBATopShotArena",
                    "fq_address": "A.0x27ece19eff91bab0.NBATopShotArena",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 47488456
                  },
                  "testnet": {
                    "address": "0x6ad6a8246cec9822",
                    "contract": "NBATopShotArena",
                    "fq_address": "A.0x6ad6a8246cec9822.NBATopShotArena",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 95783843
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488473
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783851
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488480
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783860
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47488485
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95783863
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488486
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783864
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488491
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783873
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7c058865a8a114a4ebb331d64d95bce1333ae5375602b1a9c504a70c1f23d460",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a NBATopShotInArena NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import NBATopShotArena from 0xNBATopShotArena\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NBATopShotInArena\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NBATopShotArena.Collection>(from: /storage/NBATopShotArena_Collection) == nil {\n            let collection <- NBATopShotArena.createEmptyCollection()\n            acct.save(<-collection, to: /storage/NBATopShotArena_Collection)\n        }\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/public/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/private/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/NBATopShotArena_Collection)!\n        let collectionRef = acct\n            .getCapability(/public/NBATopShotArena_Collection)\n            .borrow<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@NBATopShotArena.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xNBATopShotArena": {
                "NBATopShotArena": {
                  "mainnet": {
                    "address": "0x27ece19eff91bab0",
                    "contract": "NBATopShotArena",
                    "fq_address": "A.0x27ece19eff91bab0.NBATopShotArena",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 47488403
                  },
                  "testnet": {
                    "address": "0x6ad6a8246cec9822",
                    "contract": "NBATopShotArena",
                    "fq_address": "A.0x6ad6a8246cec9822.NBATopShotArena",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 95783780
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488421
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783788
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488428
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783798
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47488433
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95783800
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488435
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783801
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488439
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783812
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e67073d1670a5f917eaf485cb27b942ef2ab52bee0663aa007a75c723d6a8a66",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support NFLAllDay NFTs"
                }
              }
            },
            "cadence": "import AllDay from 0xAllDay\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NFLAllDay\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&AllDay.Collection>(from: /storage/AllDayNFTCollection) == nil {\n      let collection <- AllDay.createEmptyCollection()\n      signer.save(<-collection, to: /storage/AllDayNFTCollection)\n    }\n    if (signer.getCapability<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection).borrow() == nil) {\n      signer.unlink(/public/AllDayNFTCollection)\n      signer.link<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xAllDay": {
                "AllDay": {
                  "mainnet": {
                    "address": "0xe4cf4bdc1751c65d",
                    "contract": "AllDay",
                    "fq_address": "A.0xe4cf4bdc1751c65d.AllDay",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47507300
                  },
                  "testnet": {
                    "address": "0x4dfd62c88d1b6462",
                    "contract": "AllDay",
                    "fq_address": "A.0x4dfd62c88d1b6462.AllDay",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95806207
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507312
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806215
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507319
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806225
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "a39241d9994fd06acbf22c8ddc9b4e723a0d40d6aba714cd090ad248db316891",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed NFLAllDay NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import AllDay from 0xAllDay\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NFLAllDay\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AllDay.Collection>(from: /storage/AllDayNFTCollection) == nil {\n            let collection <- AllDay.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AllDayNFTCollection)\n            }\n        if (acct.getCapability<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/public/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n\n        if (acct.getCapability<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/private/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/AllDayNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xAllDay": {
                "AllDay": {
                  "mainnet": {
                    "address": "0xe4cf4bdc1751c65d",
                    "contract": "AllDay",
                    "fq_address": "A.0xe4cf4bdc1751c65d.AllDay",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47507373
                  },
                  "testnet": {
                    "address": "0x4dfd62c88d1b6462",
                    "contract": "AllDay",
                    "fq_address": "A.0x4dfd62c88d1b6462.AllDay",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95806294
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507383
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806301
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507390
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806310
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507395
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95806313
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507396
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806314
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507401
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806323
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "5db3237bc7f46bb02315e70c9e0dd9c75e647715f6343b0ac86b0477ea0ec5e8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a NFLAllDay NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import AllDay from 0xAllDay\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NFLAllDay\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AllDay.Collection>(from: /storage/AllDayNFTCollection) == nil {\n            let collection <- AllDay.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AllDayNFTCollection)\n        }\n        if (acct.getCapability<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/public/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n\n        if (acct.getCapability<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/private/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/AllDayNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/AllDayNFTCollection)\n            .borrow<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@AllDay.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xAllDay": {
                "AllDay": {
                  "mainnet": {
                    "address": "0xe4cf4bdc1751c65d",
                    "contract": "AllDay",
                    "fq_address": "A.0xe4cf4bdc1751c65d.AllDay",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47507332
                  },
                  "testnet": {
                    "address": "0x4dfd62c88d1b6462",
                    "contract": "AllDay",
                    "fq_address": "A.0x4dfd62c88d1b6462.AllDay",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95806244
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507344
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806252
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507351
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806261
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47507356
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95806263
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47507357
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95806265
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47507361
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95806274
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "6b7298592fa51be0af54c483ba1413250e2f2c3167a3d0e0468acba73e599eb2",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support NFLAllDayPacks NFTs"
                }
              }
            },
            "cadence": "import PackNFT from 0xPackNFT\nimport IPackNFT from 0xIPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NFLAllDayPacks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PackNFT.Collection>(from: /storage/PackNFTCollection) == nil {\n      let collection <- PackNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/PackNFTCollection)\n    }\n    if (signer.getCapability<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub).borrow() == nil) {\n      signer.unlink(/public/PackNFTCollectionPub)\n      signer.link<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub, target: /storage/PackNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xPackNFT": {
                "PackNFT": {
                  "mainnet": {
                    "address": "0xe4cf4bdc1751c65d",
                    "contract": "PackNFT",
                    "fq_address": "A.0xe4cf4bdc1751c65d.PackNFT",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47502748
                  },
                  "testnet": {
                    "address": "0x4dfd62c88d1b6462",
                    "contract": "PackNFT",
                    "fq_address": "A.0x4dfd62c88d1b6462.PackNFT",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95800781
                  }
                }
              },
              "0xIPackNFT": {
                "IPackNFT": {
                  "mainnet": {
                    "address": "0x44c6a6fd2281b6cc",
                    "contract": "IPackNFT",
                    "fq_address": "A.0x44c6a6fd2281b6cc.IPackNFT",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47502762
                  },
                  "testnet": {
                    "address": "0x5e3c1eb7f25e3c99",
                    "contract": "IPackNFT",
                    "fq_address": "A.0x5e3c1eb7f25e3c99.IPackNFT",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95800790
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47502769
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95800796
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47502777
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95800806
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "299746f153cd316fee8068e9d34c46e1be5271d4bccb57b371f8ce3821b295cb",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed NFLAllDayPacks NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import PackNFT from 0xPackNFT\nimport IPackNFT from 0xIPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NFLAllDayPacks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PackNFT.Collection>(from: /storage/PackNFTCollection) == nil {\n            let collection <- PackNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PackNFTCollection)\n            }\n        if (acct.getCapability<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub).borrow() == nil) {\n            acct.unlink(/public/PackNFTCollectionPub)\n            acct.link<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub, target: /storage/PackNFTCollection)\n        }\n\n        if (acct.getCapability<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv).borrow() == nil) {\n            acct.unlink(/private/PackNFTOperatorPriv)\n            acct.link<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv, target: /storage/PackNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/PackNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xPackNFT": {
                "PackNFT": {
                  "mainnet": {
                    "address": "0xe4cf4bdc1751c65d",
                    "contract": "PackNFT",
                    "fq_address": "A.0xe4cf4bdc1751c65d.PackNFT",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47502852
                  },
                  "testnet": {
                    "address": "0x4dfd62c88d1b6462",
                    "contract": "PackNFT",
                    "fq_address": "A.0x4dfd62c88d1b6462.PackNFT",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95800901
                  }
                }
              },
              "0xIPackNFT": {
                "IPackNFT": {
                  "mainnet": {
                    "address": "0x44c6a6fd2281b6cc",
                    "contract": "IPackNFT",
                    "fq_address": "A.0x44c6a6fd2281b6cc.IPackNFT",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47502867
                  },
                  "testnet": {
                    "address": "0x5e3c1eb7f25e3c99",
                    "contract": "IPackNFT",
                    "fq_address": "A.0x5e3c1eb7f25e3c99.IPackNFT",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95800910
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47502874
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95800917
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47502880
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95800927
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47502885
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95800929
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47502886
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95800930
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47502892
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95800940
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ebddb6529bfd29043301be8e362fde796125ad12851e23904245a86174d773a1",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a NFLAllDayPacks NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import PackNFT from 0xPackNFT\nimport IPackNFT from 0xIPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NFLAllDayPacks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PackNFT.Collection>(from: /storage/PackNFTCollection) == nil {\n            let collection <- PackNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PackNFTCollection)\n        }\n        if (acct.getCapability<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub).borrow() == nil) {\n            acct.unlink(/public/PackNFTCollectionPub)\n            acct.link<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub, target: /storage/PackNFTCollection)\n        }\n\n        if (acct.getCapability<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv).borrow() == nil) {\n            acct.unlink(/private/PackNFTOperatorPriv)\n            acct.link<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv, target: /storage/PackNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/PackNFTOperatorPriv)!\n        let collectionRef = acct\n            .getCapability(/public/PackNFTCollectionPub)\n            .borrow<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PackNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xPackNFT": {
                "PackNFT": {
                  "mainnet": {
                    "address": "0xe4cf4bdc1751c65d",
                    "contract": "PackNFT",
                    "fq_address": "A.0xe4cf4bdc1751c65d.PackNFT",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47502796
                  },
                  "testnet": {
                    "address": "0x4dfd62c88d1b6462",
                    "contract": "PackNFT",
                    "fq_address": "A.0x4dfd62c88d1b6462.PackNFT",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95800834
                  }
                }
              },
              "0xIPackNFT": {
                "IPackNFT": {
                  "mainnet": {
                    "address": "0x44c6a6fd2281b6cc",
                    "contract": "IPackNFT",
                    "fq_address": "A.0x44c6a6fd2281b6cc.IPackNFT",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47502810
                  },
                  "testnet": {
                    "address": "0x5e3c1eb7f25e3c99",
                    "contract": "IPackNFT",
                    "fq_address": "A.0x5e3c1eb7f25e3c99.IPackNFT",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95800842
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47502816
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95800850
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47502824
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95800859
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47502829
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95800862
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47502831
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95800863
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47502835
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95800873
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "f0bdc3a4a8b894c9585c2fa3b9536da5b4df753b542538722e37dbcc23917eed",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support PiratesOfTheMetaverse NFTs"
                }
              }
            },
            "cadence": "import PiratesOfTheMetaverse from 0xPiratesOfTheMetaverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: PiratesOfTheMetaverse\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PiratesOfTheMetaverse.Collection>(from: /storage/piratesOfTheMetaverseCollection) == nil {\n      let collection <- PiratesOfTheMetaverse.createEmptyCollection()\n      signer.save(<-collection, to: /storage/piratesOfTheMetaverseCollection)\n    }\n    if (signer.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection).borrow() == nil) {\n      signer.unlink(/public/piratesOfTheMetaverseCollection)\n      signer.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xPiratesOfTheMetaverse": {
                "PiratesOfTheMetaverse": {
                  "mainnet": {
                    "address": "0xf5fc2c119a988722",
                    "contract": "PiratesOfTheMetaverse",
                    "fq_address": "A.0xf5fc2c119a988722.PiratesOfTheMetaverse",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47492794
                  },
                  "testnet": {
                    "address": "0xc97017ed85e496bf",
                    "contract": "PiratesOfTheMetaverse",
                    "fq_address": "A.0xc97017ed85e496bf.PiratesOfTheMetaverse",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95788939
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47492806
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95788946
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47492813
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95788956
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "8335a775d6825688d2a5433d67235146f88f42b562c92adce3942d5f532444a5",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed PiratesOfTheMetaverse NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import PiratesOfTheMetaverse from 0xPiratesOfTheMetaverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: PiratesOfTheMetaverse\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PiratesOfTheMetaverse.Collection>(from: /storage/piratesOfTheMetaverseCollection) == nil {\n            let collection <- PiratesOfTheMetaverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/piratesOfTheMetaverseCollection)\n            }\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/public/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/private/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/piratesOfTheMetaverseCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xPiratesOfTheMetaverse": {
                "PiratesOfTheMetaverse": {
                  "mainnet": {
                    "address": "0xf5fc2c119a988722",
                    "contract": "PiratesOfTheMetaverse",
                    "fq_address": "A.0xf5fc2c119a988722.PiratesOfTheMetaverse",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47496606
                  },
                  "testnet": {
                    "address": "0xc97017ed85e496bf",
                    "contract": "PiratesOfTheMetaverse",
                    "fq_address": "A.0xc97017ed85e496bf.PiratesOfTheMetaverse",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95793472
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47496618
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95793479
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47496625
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95793489
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47496630
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95793491
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47496631
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95793492
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47496636
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95793502
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "d55cfaf44c3d7fade3b99202f1bfa60707b5b084b1b0951720f06bf41cca9f3f",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a PiratesOfTheMetaverse NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import PiratesOfTheMetaverse from 0xPiratesOfTheMetaverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: PiratesOfTheMetaverse\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PiratesOfTheMetaverse.Collection>(from: /storage/piratesOfTheMetaverseCollection) == nil {\n            let collection <- PiratesOfTheMetaverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/piratesOfTheMetaverseCollection)\n        }\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/public/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/private/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/piratesOfTheMetaverseCollection)!\n        let collectionRef = acct\n            .getCapability(/public/piratesOfTheMetaverseCollection)\n            .borrow<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PiratesOfTheMetaverse.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xPiratesOfTheMetaverse": {
                "PiratesOfTheMetaverse": {
                  "mainnet": {
                    "address": "0xf5fc2c119a988722",
                    "contract": "PiratesOfTheMetaverse",
                    "fq_address": "A.0xf5fc2c119a988722.PiratesOfTheMetaverse",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 47492826
                  },
                  "testnet": {
                    "address": "0xc97017ed85e496bf",
                    "contract": "PiratesOfTheMetaverse",
                    "fq_address": "A.0xc97017ed85e496bf.PiratesOfTheMetaverse",
                    "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
                    "pin_block_height": 95788979
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47492837
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95788986
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47492844
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95788995
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47492849
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95788998
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47492850
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95788999
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47492856
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95789008
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "24229807bf58412587fade77c4183fe243202045e286ec9610e278f2b112109a",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support RaceDayNFT NFTs"
                }
              }
            },
            "cadence": "import RaceDay_NFT from 0xRaceDay_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: RaceDayNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&RaceDay_NFT.Collection>(from: /storage/RaceDay_NFTCollection) == nil {\n      let collection <- RaceDay_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/RaceDay_NFTCollection)\n    }\n    if (signer.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/RaceDay_NFTCollection)\n      signer.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection, target: /storage/RaceDay_NFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xRaceDay_NFT": {
                "RaceDay_NFT": {
                  "mainnet": {
                    "address": "0x329feb3ab062d289",
                    "contract": "RaceDay_NFT",
                    "fq_address": "A.0x329feb3ab062d289.RaceDay_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510038
                  },
                  "testnet": {
                    "address": "0x04625c28593d9408",
                    "contract": "RaceDay_NFT",
                    "fq_address": "A.0x04625c28593d9408.RaceDay_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809443
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510050
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809450
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510058
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809459
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "60c957cc7c0ae54126c72d7a064440fd7d80824a47a82a8a2e7f684d1335d1de",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed RaceDayNFT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import RaceDay_NFT from 0xRaceDay_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: RaceDayNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RaceDay_NFT.Collection>(from: /storage/RaceDay_NFTCollection) == nil {\n            let collection <- RaceDay_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RaceDay_NFTCollection)\n            }\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/RaceDay_NFTCollection)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection, target: /storage/RaceDay_NFTCollection)\n        }\n\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT).borrow() == nil) {\n            acct.unlink(/private/RaceDay_NFT)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT, target: /storage/RaceDay_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/RaceDay_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xRaceDay_NFT": {
                "RaceDay_NFT": {
                  "mainnet": {
                    "address": "0x329feb3ab062d289",
                    "contract": "RaceDay_NFT",
                    "fq_address": "A.0x329feb3ab062d289.RaceDay_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510112
                  },
                  "testnet": {
                    "address": "0x04625c28593d9408",
                    "contract": "RaceDay_NFT",
                    "fq_address": "A.0x04625c28593d9408.RaceDay_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809531
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510124
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809538
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510130
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809548
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47510135
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809551
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510136
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809552
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510141
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809562
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "2b6ec5902718013619a61f6e630c3bfa1c9a17ab9c8a0fcb99ab3de3ba210d2a",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a RaceDayNFT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import RaceDay_NFT from 0xRaceDay_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: RaceDayNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RaceDay_NFT.Collection>(from: /storage/RaceDay_NFTCollection) == nil {\n            let collection <- RaceDay_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RaceDay_NFTCollection)\n        }\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/RaceDay_NFTCollection)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection, target: /storage/RaceDay_NFTCollection)\n        }\n\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT).borrow() == nil) {\n            acct.unlink(/private/RaceDay_NFT)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT, target: /storage/RaceDay_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/RaceDay_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/RaceDay_NFTCollection)\n            .borrow<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@RaceDay_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xRaceDay_NFT": {
                "RaceDay_NFT": {
                  "mainnet": {
                    "address": "0x329feb3ab062d289",
                    "contract": "RaceDay_NFT",
                    "fq_address": "A.0x329feb3ab062d289.RaceDay_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510071
                  },
                  "testnet": {
                    "address": "0x04625c28593d9408",
                    "contract": "RaceDay_NFT",
                    "fq_address": "A.0x04625c28593d9408.RaceDay_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809480
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510083
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809487
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510087
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809497
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47510094
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809499
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510094
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809501
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510099
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809510
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "5a2aff3baad77f36f6d24463a5fefecd073f08184d3fe050ca36cbf45484881e",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support schmoes_pre_launch_token NFTs"
                }
              }
            },
            "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: schmoes_pre_launch_token\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n      let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n    }\n    if (signer.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n      signer.unlink(/public/SchmoesPreLaunchTokenCollection)\n      signer.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xSchmoesPreLaunchToken": {
                "SchmoesPreLaunchToken": {
                  "testnet": {
                    "address": "0x44510157a80ad550",
                    "contract": "SchmoesPreLaunchToken",
                    "fq_address": "A.0x44510157a80ad550.SchmoesPreLaunchToken",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813946
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813949
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813954
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "36812f011aaab31a1d01a6cbc5c8e143f5dec87afcb56569524bbbba7aba2913",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed schmoes_pre_launch_token NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: schmoes_pre_launch_token\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n            let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n            }\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/public/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/private/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SchmoesPreLaunchTokenCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xSchmoesPreLaunchToken": {
                "SchmoesPreLaunchToken": {
                  "testnet": {
                    "address": "0x44510157a80ad550",
                    "contract": "SchmoesPreLaunchToken",
                    "fq_address": "A.0x44510157a80ad550.SchmoesPreLaunchToken",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813987
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813991
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813995
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813997
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813997
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95814002
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "65b8c4d3073b5ed3a248b7b2ca09da29a4d245170e4096679972c0ad4ce0a0d3",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a schmoes_pre_launch_token NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: schmoes_pre_launch_token\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n            let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n        }\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/public/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/private/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SchmoesPreLaunchTokenCollection)!\n        let collectionRef = acct\n            .getCapability(/public/SchmoesPreLaunchTokenCollection)\n            .borrow<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SchmoesPreLaunchToken.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xSchmoesPreLaunchToken": {
                "SchmoesPreLaunchToken": {
                  "testnet": {
                    "address": "0x44510157a80ad550",
                    "contract": "SchmoesPreLaunchToken",
                    "fq_address": "A.0x44510157a80ad550.SchmoesPreLaunchToken",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813962
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813966
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813971
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813972
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813973
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813977
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e034f1505d4851229cd060e26eb7acc485444160f2747480bb613bc855b3cc79",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support SequelDigitalArt NFTs"
                }
              }
            },
            "cadence": "import DigitalArt from 0xDigitalArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SequelDigitalArt\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DigitalArt.Collection>(from: /storage/sequelDigitalArtCollection) == nil {\n      let collection <- DigitalArt.createEmptyCollection()\n      signer.save(<-collection, to: /storage/sequelDigitalArtCollection)\n    }\n    if (signer.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection).borrow() == nil) {\n      signer.unlink(/public/sequelDigitalArtCollection)\n      signer.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xDigitalArt": {
                "DigitalArt": {
                  "mainnet": {
                    "address": "0x3cb7ceeb625a600a",
                    "contract": "DigitalArt",
                    "fq_address": "A.0x3cb7ceeb625a600a.DigitalArt",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47498553
                  },
                  "testnet": {
                    "address": "0x745b085dafdd4fc0",
                    "contract": "DigitalArt",
                    "fq_address": "A.0x745b085dafdd4fc0.DigitalArt",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95795809
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498571
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95795817
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498578
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95795826
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "70791b8d0c259fcaad9656daa43a787927efb90bcbc7a508286bdc8a2ccf7c0d",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed SequelDigitalArt NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import DigitalArt from 0xDigitalArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SequelDigitalArt\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DigitalArt.Collection>(from: /storage/sequelDigitalArtCollection) == nil {\n            let collection <- DigitalArt.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sequelDigitalArtCollection)\n            }\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/public/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/private/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/sequelDigitalArtCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xDigitalArt": {
                "DigitalArt": {
                  "mainnet": {
                    "address": "0x3cb7ceeb625a600a",
                    "contract": "DigitalArt",
                    "fq_address": "A.0x3cb7ceeb625a600a.DigitalArt",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47498656
                  },
                  "testnet": {
                    "address": "0x745b085dafdd4fc0",
                    "contract": "DigitalArt",
                    "fq_address": "A.0x745b085dafdd4fc0.DigitalArt",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95795934
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498675
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95795942
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498683
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95795951
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47498687
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95795953
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498689
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95795955
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498693
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95795964
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "5e049ce3daf98ec65206bfbb4b566add59716548a6f5e7f6ec86fa7e4dc837bc",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a SequelDigitalArt NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import DigitalArt from 0xDigitalArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SequelDigitalArt\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DigitalArt.Collection>(from: /storage/sequelDigitalArtCollection) == nil {\n            let collection <- DigitalArt.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sequelDigitalArtCollection)\n        }\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/public/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/private/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/sequelDigitalArtCollection)!\n        let collectionRef = acct\n            .getCapability(/public/sequelDigitalArtCollection)\n            .borrow<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DigitalArt.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xDigitalArt": {
                "DigitalArt": {
                  "mainnet": {
                    "address": "0x3cb7ceeb625a600a",
                    "contract": "DigitalArt",
                    "fq_address": "A.0x3cb7ceeb625a600a.DigitalArt",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47498599
                  },
                  "testnet": {
                    "address": "0x745b085dafdd4fc0",
                    "contract": "DigitalArt",
                    "fq_address": "A.0x745b085dafdd4fc0.DigitalArt",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95795865
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498616
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95795872
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498624
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95795881
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47498629
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95795884
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498630
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95795885
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498635
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95795895
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "21a06594d9b250c9bf35ac8c6cb059015cc205d0fc97f40518cfc079bbdc3570",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support SeussiblesNFTCollectionbyTibles NFTs"
                }
              }
            },
            "cadence": "import DrSeuss from 0xDrSeuss\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DrSeuss.Collection>(from: /storage/TiblesDrSeussCollection) == nil {\n      let collection <- DrSeuss.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TiblesDrSeussCollection)\n    }\n    if (signer.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection).borrow() == nil) {\n      signer.unlink(/public/TiblesDrSeussCollection)\n      signer.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection, target: /storage/TiblesDrSeussCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xTiblesNFT": {
                "TiblesNFT": {
                  "testnet": {
                    "address": "0xe93c412c964bdf40",
                    "contract": "TiblesNFT",
                    "fq_address": "A.0xe93c412c964bdf40.TiblesNFT",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95800974
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95800978
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95800983
                  }
                }
              },
              "0xDrSeuss": {
                "DrSeuss": {
                  "testnet": {
                    "address": "0xff68241f0f4fd521",
                    "contract": "DrSeuss",
                    "fq_address": "A.0xff68241f0f4fd521.DrSeuss",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95800994
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "aa000535c747f11de16573bf7631fde7ec179ac1ce17fe65f96a03ea770a84fc",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed SeussiblesNFTCollectionbyTibles NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import DrSeuss from 0xDrSeuss\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DrSeuss.Collection>(from: /storage/TiblesDrSeussCollection) == nil {\n            let collection <- DrSeuss.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesDrSeussCollection)\n            }\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesDrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection).borrow() == nil) {\n            acct.unlink(/private/DrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TiblesDrSeussCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xTiblesNFT": {
                "TiblesNFT": {
                  "testnet": {
                    "address": "0xe93c412c964bdf40",
                    "contract": "TiblesNFT",
                    "fq_address": "A.0xe93c412c964bdf40.TiblesNFT",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801078
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801081
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801086
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95801087
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801087
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801092
                  }
                }
              },
              "0xDrSeuss": {
                "DrSeuss": {
                  "testnet": {
                    "address": "0xff68241f0f4fd521",
                    "contract": "DrSeuss",
                    "fq_address": "A.0xff68241f0f4fd521.DrSeuss",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95801103
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "fede0e6ccbbff1f8f91852ecfec1d52a3f37286a6ea0632f48006a779111f198",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a SeussiblesNFTCollectionbyTibles NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import DrSeuss from 0xDrSeuss\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DrSeuss.Collection>(from: /storage/TiblesDrSeussCollection) == nil {\n            let collection <- DrSeuss.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesDrSeussCollection)\n        }\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesDrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection).borrow() == nil) {\n            acct.unlink(/private/DrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DrSeussCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TiblesDrSeussCollection)\n            .borrow<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DrSeuss.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xTiblesNFT": {
                "TiblesNFT": {
                  "testnet": {
                    "address": "0xe93c412c964bdf40",
                    "contract": "TiblesNFT",
                    "fq_address": "A.0xe93c412c964bdf40.TiblesNFT",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801025
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801029
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801033
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95801035
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95801035
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95801040
                  }
                }
              },
              "0xDrSeuss": {
                "DrSeuss": {
                  "testnet": {
                    "address": "0xff68241f0f4fd521",
                    "contract": "DrSeuss",
                    "fq_address": "A.0xff68241f0f4fd521.DrSeuss",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95801051
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "89b5d179d0ecf70292763c9a15110eca9fdd32eff28e958e36564fcd04678903",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support SportsIconCollection NFTs"
                }
              }
            },
            "cadence": "import SportsIconCollectible from 0xSportsIconCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SportsIconCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SportsIconCollectible.Collection>(from: /storage/sportsIconCollectibleCollection) == nil {\n      let collection <- SportsIconCollectible.createEmptyCollection()\n      signer.save(<-collection, to: /storage/sportsIconCollectibleCollection)\n    }\n    if (signer.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection).borrow() == nil) {\n      signer.unlink(/public/sportsIconCollectibleCollection)\n      signer.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xSportsIconCollectible": {
                "SportsIconCollectible": {
                  "mainnet": {
                    "address": "0x8de96244f54db422",
                    "contract": "SportsIconCollectible",
                    "fq_address": "A.0x8de96244f54db422.SportsIconCollectible",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47499127
                  },
                  "testnet": {
                    "address": "0xaf4725f17cc7afdb",
                    "contract": "SportsIconCollectible",
                    "fq_address": "A.0xaf4725f17cc7afdb.SportsIconCollectible",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95796483
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499142
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796491
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499148
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796500
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7481f5707f2ceb507c72270587e9232584ee217dc838f58cdc1aac66823961c3",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed SportsIconCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import SportsIconCollectible from 0xSportsIconCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SportsIconCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SportsIconCollectible.Collection>(from: /storage/sportsIconCollectibleCollection) == nil {\n            let collection <- SportsIconCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sportsIconCollectibleCollection)\n            }\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/sportsIconCollectibleCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xSportsIconCollectible": {
                "SportsIconCollectible": {
                  "mainnet": {
                    "address": "0x8de96244f54db422",
                    "contract": "SportsIconCollectible",
                    "fq_address": "A.0x8de96244f54db422.SportsIconCollectible",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47499212
                  },
                  "testnet": {
                    "address": "0xaf4725f17cc7afdb",
                    "contract": "SportsIconCollectible",
                    "fq_address": "A.0xaf4725f17cc7afdb.SportsIconCollectible",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95796583
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499224
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796590
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499232
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796599
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499237
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95796602
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499238
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796603
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499244
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796612
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "99707d39df213c705dbcee17270f839dc7e757ed75f634329162ab117548c3d6",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a SportsIconCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import SportsIconCollectible from 0xSportsIconCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SportsIconCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SportsIconCollectible.Collection>(from: /storage/sportsIconCollectibleCollection) == nil {\n            let collection <- SportsIconCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sportsIconCollectibleCollection)\n        }\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/sportsIconCollectibleCollection)!\n        let collectionRef = acct\n            .getCapability(/public/sportsIconCollectibleCollection)\n            .borrow<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SportsIconCollectible.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xSportsIconCollectible": {
                "SportsIconCollectible": {
                  "mainnet": {
                    "address": "0x8de96244f54db422",
                    "contract": "SportsIconCollectible",
                    "fq_address": "A.0x8de96244f54db422.SportsIconCollectible",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47499165
                  },
                  "testnet": {
                    "address": "0xaf4725f17cc7afdb",
                    "contract": "SportsIconCollectible",
                    "fq_address": "A.0xaf4725f17cc7afdb.SportsIconCollectible",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95796527
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499180
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796534
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499185
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796544
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47499190
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95796546
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47499193
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796547
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47499197
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796557
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "288fb46ba2ede05c30cd00fac1b38e715351ee087c764f974f8f01106e256f78",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support StanzClubCollection NFTs"
                }
              }
            },
            "cadence": "import StanzClub from 0xStanzClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: StanzClubCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&StanzClub.Collection>(from: /storage/StanzClubCollection) == nil {\n      let collection <- StanzClub.createEmptyCollection()\n      signer.save(<-collection, to: /storage/StanzClubCollection)\n    }\n    if (signer.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection).borrow() == nil) {\n      signer.unlink(/public/StanzClubCollection)\n      signer.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection, target: /storage/StanzClubCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xStanzClub": {
                "StanzClub": {
                  "mainnet": {
                    "address": "0xda421c78e2f7e0e7",
                    "contract": "StanzClub",
                    "fq_address": "A.0xda421c78e2f7e0e7.StanzClub",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47509627
                  },
                  "testnet": {
                    "address": "0x87dc938d9246d780",
                    "contract": "StanzClub",
                    "fq_address": "A.0x87dc938d9246d780.StanzClub",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95808966
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509640
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808973
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509645
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808982
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0e726a5750505ab6f00182d3ae6e00136601b9bb454205db47c51d1d27eed1e2",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed StanzClubCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import StanzClub from 0xStanzClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: StanzClubCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StanzClub.Collection>(from: /storage/StanzClubCollection) == nil {\n            let collection <- StanzClub.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StanzClubCollection)\n            }\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/public/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/private/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/StanzClubCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xStanzClub": {
                "StanzClub": {
                  "mainnet": {
                    "address": "0xda421c78e2f7e0e7",
                    "contract": "StanzClub",
                    "fq_address": "A.0xda421c78e2f7e0e7.StanzClub",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47509700
                  },
                  "testnet": {
                    "address": "0x87dc938d9246d780",
                    "contract": "StanzClub",
                    "fq_address": "A.0x87dc938d9246d780.StanzClub",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95809049
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509711
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809057
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509719
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809067
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47509723
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809068
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509725
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809069
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509729
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809079
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "fcba820a56d93f06ef06d0dc40d7ca4bdde86d712310d90ddc5883114865c3f0",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a StanzClubCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import StanzClub from 0xStanzClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: StanzClubCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StanzClub.Collection>(from: /storage/StanzClubCollection) == nil {\n            let collection <- StanzClub.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StanzClubCollection)\n        }\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/public/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/private/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/StanzClubCollection)!\n        let collectionRef = acct\n            .getCapability(/public/StanzClubCollection)\n            .borrow<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@StanzClub.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xStanzClub": {
                "StanzClub": {
                  "mainnet": {
                    "address": "0xda421c78e2f7e0e7",
                    "contract": "StanzClub",
                    "fq_address": "A.0xda421c78e2f7e0e7.StanzClub",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47509657
                  },
                  "testnet": {
                    "address": "0x87dc938d9246d780",
                    "contract": "StanzClub",
                    "fq_address": "A.0x87dc938d9246d780.StanzClub",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95809002
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509669
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809009
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509675
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809018
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47509682
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809020
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509682
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809021
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509687
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809030
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e7013553cf7f695ccc0febc73b4027458a00e4628a46f824e7df61bbc4294414",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Starly NFTs"
                }
              }
            },
            "cadence": "import StarlyCard from 0xStarlyCard\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Starly\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&StarlyCard.Collection>(from: /storage/starlyCardCollection) == nil {\n      let collection <- StarlyCard.createEmptyCollection()\n      signer.save(<-collection, to: /storage/starlyCardCollection)\n    }\n    if (signer.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection).borrow() == nil) {\n      signer.unlink(/public/starlyCardCollection)\n      signer.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection, target: /storage/starlyCardCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xStarlyCard": {
                "StarlyCard": {
                  "mainnet": {
                    "address": "0x5b82f21c0edf76e3",
                    "contract": "StarlyCard",
                    "fq_address": "A.0x5b82f21c0edf76e3.StarlyCard",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 47489155
                  },
                  "testnet": {
                    "address": "0x697d72a988a77070",
                    "contract": "StarlyCard",
                    "fq_address": "A.0x697d72a988a77070.StarlyCard",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 95784675
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489172
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784682
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489180
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784692
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "94eddee0ffcbc167d095232a8c7da1df450d4959ea28f020c07f77a388e656db",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Starly NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import StarlyCard from 0xStarlyCard\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Starly\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StarlyCard.Collection>(from: /storage/starlyCardCollection) == nil {\n            let collection <- StarlyCard.createEmptyCollection()\n            acct.save(<-collection, to: /storage/starlyCardCollection)\n            }\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/public/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/private/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/starlyCardCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xStarlyCard": {
                "StarlyCard": {
                  "mainnet": {
                    "address": "0x5b82f21c0edf76e3",
                    "contract": "StarlyCard",
                    "fq_address": "A.0x5b82f21c0edf76e3.StarlyCard",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 47489260
                  },
                  "testnet": {
                    "address": "0x697d72a988a77070",
                    "contract": "StarlyCard",
                    "fq_address": "A.0x697d72a988a77070.StarlyCard",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 95784797
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489278
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784805
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489287
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784814
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47489291
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95784817
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489292
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784818
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489296
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784828
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7a29b26ca99e3ad94834d58cdc0d10c84a91d90c6a85dfdcdc8cdcfff9a361b1",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Starly NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import StarlyCard from 0xStarlyCard\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Starly\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StarlyCard.Collection>(from: /storage/starlyCardCollection) == nil {\n            let collection <- StarlyCard.createEmptyCollection()\n            acct.save(<-collection, to: /storage/starlyCardCollection)\n        }\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/public/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/private/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/starlyCardCollection)!\n        let collectionRef = acct\n            .getCapability(/public/starlyCardCollection)\n            .borrow<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@StarlyCard.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xStarlyCard": {
                "StarlyCard": {
                  "mainnet": {
                    "address": "0x5b82f21c0edf76e3",
                    "contract": "StarlyCard",
                    "fq_address": "A.0x5b82f21c0edf76e3.StarlyCard",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 47489202
                  },
                  "testnet": {
                    "address": "0x697d72a988a77070",
                    "contract": "StarlyCard",
                    "fq_address": "A.0x697d72a988a77070.StarlyCard",
                    "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
                    "pin_block_height": 95784729
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489220
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784737
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489229
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784747
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47489234
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95784749
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47489235
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95784750
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47489240
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95784760
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "eaba502382a810ae9e6b7303ab7ff1ffa3ea3dacc5ca8b3d9546d78c18ef5a60",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support StoreFrontTR NFTs"
                }
              }
            },
            "cadence": "import StoreFront from 0xStoreFront\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: StoreFrontTR\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&StoreFront.Collection>(from: /storage/StoreFrontCollection) == nil {\n      let collection <- StoreFront.createEmptyCollection()\n      signer.save(<-collection, to: /storage/StoreFrontCollection)\n    }\n    if (signer.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection).borrow() == nil) {\n      signer.unlink(/public/StoreFrontCollection)\n      signer.link<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection, target: /storage/StoreFrontCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xStoreFront": {
                "StoreFront": {
                  "mainnet": {
                    "address": "0x766b859539a6679b",
                    "contract": "StoreFront",
                    "fq_address": "A.0x766b859539a6679b.StoreFront",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 47496955
                  },
                  "testnet": {
                    "address": "0x34d2a0f0a4f8c6e8",
                    "contract": "StoreFront",
                    "fq_address": "A.0x34d2a0f0a4f8c6e8.StoreFront",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95793896
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47496969
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95793903
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47496977
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95793913
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "2c90cbe23ad4d4c1c1ac953a90a605ee10edb7d6e3cda16da7eee2c073b7b482",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed StoreFrontTR NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import StoreFront from 0xStoreFront\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: StoreFrontTR\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StoreFront.Collection>(from: /storage/StoreFrontCollection) == nil {\n            let collection <- StoreFront.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StoreFrontCollection)\n            }\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection).borrow() == nil) {\n            acct.unlink(/public/StoreFrontCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection, target: /storage/StoreFrontCollection)\n        }\n\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection).borrow() == nil) {\n            acct.unlink(/private/storeFrontNFTCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection, target: /storage/StoreFrontCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/StoreFrontCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xStoreFront": {
                "StoreFront": {
                  "mainnet": {
                    "address": "0x766b859539a6679b",
                    "contract": "StoreFront",
                    "fq_address": "A.0x766b859539a6679b.StoreFront",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 47498757
                  },
                  "testnet": {
                    "address": "0x34d2a0f0a4f8c6e8",
                    "contract": "StoreFront",
                    "fq_address": "A.0x34d2a0f0a4f8c6e8.StoreFront",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95796054
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498772
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796061
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498779
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796070
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47498783
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95796072
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498784
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796073
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498791
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796083
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "261a8941bef03039ecbfd545a863def4df36354e0b58bd87bc192ba2b5184abe",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a StoreFrontTR NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import StoreFront from 0xStoreFront\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: StoreFrontTR\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StoreFront.Collection>(from: /storage/StoreFrontCollection) == nil {\n            let collection <- StoreFront.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StoreFrontCollection)\n        }\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection).borrow() == nil) {\n            acct.unlink(/public/StoreFrontCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection, target: /storage/StoreFrontCollection)\n        }\n\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection).borrow() == nil) {\n            acct.unlink(/private/storeFrontNFTCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection, target: /storage/StoreFrontCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/storeFrontNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/StoreFrontCollection)\n            .borrow<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@StoreFront.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xStoreFront": {
                "StoreFront": {
                  "mainnet": {
                    "address": "0x766b859539a6679b",
                    "contract": "StoreFront",
                    "fq_address": "A.0x766b859539a6679b.StoreFront",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 47498710
                  },
                  "testnet": {
                    "address": "0x34d2a0f0a4f8c6e8",
                    "contract": "StoreFront",
                    "fq_address": "A.0x34d2a0f0a4f8c6e8.StoreFront",
                    "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
                    "pin_block_height": 95795994
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498724
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796001
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498732
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796010
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47498737
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95796013
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47498738
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95796014
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47498742
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95796024
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0c91871e5c928468598090b8a6c56ccacff609cc48778c6a6e41f0c0ffd2a37c",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support TestEditionsNFTs NFTs"
                }
              }
            },
            "cadence": "import TestEditionsNfTs from 0xTestEditionsNfTs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TestEditionsNFTs\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TestEditionsNfTs.Collection>(from: /storage/TestEditionsNfTs_Collection) == nil {\n      let collection <- TestEditionsNfTs.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TestEditionsNfTs_Collection)\n    }\n    if (signer.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection).borrow() == nil) {\n      signer.unlink(/public/TestEditionsNfTs_Collection)\n      signer.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xTestEditionsNfTs": {
                "TestEditionsNfTs": {
                  "testnet": {
                    "address": "0x4f2b9df936b8ee37",
                    "contract": "TestEditionsNfTs",
                    "fq_address": "A.0x4f2b9df936b8ee37.TestEditionsNfTs",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 95813793
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813796
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813801
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "f3da9603e176a10c014dae840f1f556904c2177b21419be19c369b49b553f2c8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed TestEditionsNFTs NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TestEditionsNfTs from 0xTestEditionsNfTs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TestEditionsNFTs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TestEditionsNfTs.Collection>(from: /storage/TestEditionsNfTs_Collection) == nil {\n            let collection <- TestEditionsNfTs.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TestEditionsNfTs_Collection)\n            }\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/public/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/private/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TestEditionsNfTs_Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xTestEditionsNfTs": {
                "TestEditionsNfTs": {
                  "testnet": {
                    "address": "0x4f2b9df936b8ee37",
                    "contract": "TestEditionsNfTs",
                    "fq_address": "A.0x4f2b9df936b8ee37.TestEditionsNfTs",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 95813846
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813849
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813853
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813854
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813855
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813859
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "fe73856c6f475a92b7152d74831e49cc1f0a87f01ab1c5462ce23cd0bc2f6d10",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a TestEditionsNFTs NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TestEditionsNfTs from 0xTestEditionsNfTs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TestEditionsNFTs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TestEditionsNfTs.Collection>(from: /storage/TestEditionsNfTs_Collection) == nil {\n            let collection <- TestEditionsNfTs.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TestEditionsNfTs_Collection)\n        }\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/public/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/private/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TestEditionsNfTs_Collection)!\n        let collectionRef = acct\n            .getCapability(/public/TestEditionsNfTs_Collection)\n            .borrow<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TestEditionsNfTs.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xTestEditionsNfTs": {
                "TestEditionsNfTs": {
                  "testnet": {
                    "address": "0x4f2b9df936b8ee37",
                    "contract": "TestEditionsNfTs",
                    "fq_address": "A.0x4f2b9df936b8ee37.TestEditionsNfTs",
                    "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
                    "pin_block_height": 95813816
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813819
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813824
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813825
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813826
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813830
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "88b22fafda22b717b43059d830792d3d03f397652ceb790aca34b016392ffee8",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support TheCharlieCollection NFTs"
                }
              }
            },
            "cadence": "import CharlieNFT from 0xCharlieNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheCharlieCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CharlieNFT.Collection>(from: /storage/CharlieNFTCollection) == nil {\n      let collection <- CharlieNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CharlieNFTCollection)\n    }\n    if (signer.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection).borrow() == nil) {\n      signer.unlink(/public/CharlieNFTCollection)\n      signer.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xCharlieNFT": {
                "CharlieNFT": {
                  "testnet": {
                    "address": "0x0c7f58ca4b64219d",
                    "contract": "CharlieNFT",
                    "fq_address": "A.0x0c7f58ca4b64219d.CharlieNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813715
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813719
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813724
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "fcbcee8e830efa963b88eab773b8d96a1821d98c24e4ae4dbde77c734854189b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed TheCharlieCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CharlieNFT from 0xCharlieNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheCharlieCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CharlieNFT.Collection>(from: /storage/CharlieNFTCollection) == nil {\n            let collection <- CharlieNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CharlieNFTCollection)\n            }\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/public/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/private/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CharlieNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xCharlieNFT": {
                "CharlieNFT": {
                  "testnet": {
                    "address": "0x0c7f58ca4b64219d",
                    "contract": "CharlieNFT",
                    "fq_address": "A.0x0c7f58ca4b64219d.CharlieNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813758
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813761
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813766
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813767
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813768
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813773
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "adf6e15b6f42e3d8a626be8694384b821b30dd6710b02a9ac9aabcf775b796a4",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a TheCharlieCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CharlieNFT from 0xCharlieNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheCharlieCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CharlieNFT.Collection>(from: /storage/CharlieNFTCollection) == nil {\n            let collection <- CharlieNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CharlieNFTCollection)\n        }\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/public/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/private/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CharlieNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/CharlieNFTCollection)\n            .borrow<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CharlieNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xCharlieNFT": {
                "CharlieNFT": {
                  "testnet": {
                    "address": "0x0c7f58ca4b64219d",
                    "contract": "CharlieNFT",
                    "fq_address": "A.0x0c7f58ca4b64219d.CharlieNFT",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813734
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813737
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813742
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813743
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813743
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813748
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "05ca10b82751f6676ea193cc5059c87489a5acf0c4a0245b1f71ebca61ec19f3",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support ThePublishedNFTCollection NFTs"
                }
              }
            },
            "cadence": "import PublishedNFT from 0xPublishedNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ThePublishedNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PublishedNFT.Collection>(from: /storage/publishedNFTCollection) == nil {\n      let collection <- PublishedNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/publishedNFTCollection)\n    }\n    if (signer.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection).borrow() == nil) {\n      signer.unlink(/public/publishedNFTCollection)\n      signer.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection, target: /storage/publishedNFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xPublishedNFT": {
                "PublishedNFT": {
                  "mainnet": {
                    "address": "0x52cbea4e6f616b8e",
                    "contract": "PublishedNFT",
                    "fq_address": "A.0x52cbea4e6f616b8e.PublishedNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47501930
                  },
                  "testnet": {
                    "address": "0x00af2ab363fa49e4",
                    "contract": "PublishedNFT",
                    "fq_address": "A.0x00af2ab363fa49e4.PublishedNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95799811
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501941
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799819
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501950
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799828
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "560287dad7950aa72cd978f2ef782303c1ced79426e90e9277bcf7577155861b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed ThePublishedNFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import PublishedNFT from 0xPublishedNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ThePublishedNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PublishedNFT.Collection>(from: /storage/publishedNFTCollection) == nil {\n            let collection <- PublishedNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/publishedNFTCollection)\n            }\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection).borrow() == nil) {\n            acct.unlink(/public/publishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection).borrow() == nil) {\n            acct.unlink(/private/PublishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/publishedNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xPublishedNFT": {
                "PublishedNFT": {
                  "mainnet": {
                    "address": "0x52cbea4e6f616b8e",
                    "contract": "PublishedNFT",
                    "fq_address": "A.0x52cbea4e6f616b8e.PublishedNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47502006
                  },
                  "testnet": {
                    "address": "0x00af2ab363fa49e4",
                    "contract": "PublishedNFT",
                    "fq_address": "A.0x00af2ab363fa49e4.PublishedNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95799898
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47502019
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799905
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47502027
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799915
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47502033
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95799917
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47502034
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799918
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47502039
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799928
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "c30e9ebe10ecc8244312d7dd9af3bb86b82f16fa7d7b9c4f9ba99863b1eb89e3",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a ThePublishedNFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import PublishedNFT from 0xPublishedNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ThePublishedNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PublishedNFT.Collection>(from: /storage/publishedNFTCollection) == nil {\n            let collection <- PublishedNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/publishedNFTCollection)\n        }\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection).borrow() == nil) {\n            acct.unlink(/public/publishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection).borrow() == nil) {\n            acct.unlink(/private/PublishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/PublishedNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/publishedNFTCollection)\n            .borrow<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PublishedNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xPublishedNFT": {
                "PublishedNFT": {
                  "mainnet": {
                    "address": "0x52cbea4e6f616b8e",
                    "contract": "PublishedNFT",
                    "fq_address": "A.0x52cbea4e6f616b8e.PublishedNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47501962
                  },
                  "testnet": {
                    "address": "0x00af2ab363fa49e4",
                    "contract": "PublishedNFT",
                    "fq_address": "A.0x00af2ab363fa49e4.PublishedNFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95799849
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501975
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799856
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501981
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799864
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47501986
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95799867
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47501988
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95799868
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47501993
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95799878
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "51c2921c79a0d15c7583493528292af2ea2a1db00c53859c24b163fc522eb037",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support ThingFundMembershipBadge NFTs"
                }
              }
            },
            "cadence": "import CaaPass from 0xCaaPass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ThingFundMembershipBadge\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CaaPass.Collection>(from: /storage/caaPassCollection) == nil {\n      let collection <- CaaPass.createEmptyCollection()\n      signer.save(<-collection, to: /storage/caaPassCollection)\n    }\n    if (signer.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection).borrow() == nil) {\n      signer.unlink(/public/caaPassCollection)\n      signer.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection, target: /storage/caaPassCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xCaaPass": {
                "CaaPass": {
                  "mainnet": {
                    "address": "0x98c9c2e548b84d31",
                    "contract": "CaaPass",
                    "fq_address": "A.0x98c9c2e548b84d31.CaaPass",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505662
                  },
                  "testnet": {
                    "address": "0xa8b1239250f8d342",
                    "contract": "CaaPass",
                    "fq_address": "A.0xa8b1239250f8d342.CaaPass",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804251
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505672
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804259
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505679
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804269
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "a8ad032570083c8c8dfe373a7cc0c090b110765b9fade3ec996054379611c39a",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed ThingFundMembershipBadge NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CaaPass from 0xCaaPass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ThingFundMembershipBadge\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CaaPass.Collection>(from: /storage/caaPassCollection) == nil {\n            let collection <- CaaPass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/caaPassCollection)\n            }\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection).borrow() == nil) {\n            acct.unlink(/public/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection, target: /storage/caaPassCollection)\n        }\n\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection).borrow() == nil) {\n            acct.unlink(/private/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection, target: /storage/caaPassCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/caaPassCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xCaaPass": {
                "CaaPass": {
                  "mainnet": {
                    "address": "0x98c9c2e548b84d31",
                    "contract": "CaaPass",
                    "fq_address": "A.0x98c9c2e548b84d31.CaaPass",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505731
                  },
                  "testnet": {
                    "address": "0xa8b1239250f8d342",
                    "contract": "CaaPass",
                    "fq_address": "A.0xa8b1239250f8d342.CaaPass",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804337
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505742
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804344
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505750
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804353
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505755
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804355
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505755
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804356
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505759
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804367
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "e0d2b11d7fbc8eb1a2b711651da0294c74ef6c63c1d7b4a6ae2083b9b46bd547",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a ThingFundMembershipBadge NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import CaaPass from 0xCaaPass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ThingFundMembershipBadge\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CaaPass.Collection>(from: /storage/caaPassCollection) == nil {\n            let collection <- CaaPass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/caaPassCollection)\n        }\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection).borrow() == nil) {\n            acct.unlink(/public/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection, target: /storage/caaPassCollection)\n        }\n\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection).borrow() == nil) {\n            acct.unlink(/private/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection, target: /storage/caaPassCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/caaPassCollection)!\n        let collectionRef = acct\n            .getCapability(/public/caaPassCollection)\n            .borrow<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CaaPass.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xCaaPass": {
                "CaaPass": {
                  "mainnet": {
                    "address": "0x98c9c2e548b84d31",
                    "contract": "CaaPass",
                    "fq_address": "A.0x98c9c2e548b84d31.CaaPass",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47505692
                  },
                  "testnet": {
                    "address": "0xa8b1239250f8d342",
                    "contract": "CaaPass",
                    "fq_address": "A.0xa8b1239250f8d342.CaaPass",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95804287
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505702
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804294
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505710
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804304
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47505714
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95804306
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47505716
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95804308
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47505720
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95804317
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "8ae86ef9c995b8005b5fd5ae48168c54628f0b324830fb5d2e010ebcc7988f03",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support TicalUniverseUAT NFTs"
                }
              }
            },
            "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TicalUniverseUAT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n      let collection <- TicalUniverse.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TicalUniverseCollection)\n    }\n    if (signer.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n      signer.unlink(/public/TicalUniverseCollection)\n      signer.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xTicalUniverse": {
                "TicalUniverse": {
                  "testnet": {
                    "address": "0x58b60c5240d3f39b",
                    "contract": "TicalUniverse",
                    "fq_address": "A.0x58b60c5240d3f39b.TicalUniverse",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813329
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813332
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813337
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ff66c6320d66ad46cefc3c209eb20807675df12406e346d650580b00da1aba34",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed TicalUniverseUAT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TicalUniverseUAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n            let collection <- TicalUniverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TicalUniverseCollection)\n            }\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/public/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/private/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TicalUniverseCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xTicalUniverse": {
                "TicalUniverse": {
                  "testnet": {
                    "address": "0x58b60c5240d3f39b",
                    "contract": "TicalUniverse",
                    "fq_address": "A.0x58b60c5240d3f39b.TicalUniverse",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813372
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813376
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813381
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813382
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813383
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813388
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "938479e7b2c6e6d0650bf3e08e7707eb0a87c991caa3fc001643da47d040aafc",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a TicalUniverseUAT NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TicalUniverseUAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n            let collection <- TicalUniverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TicalUniverseCollection)\n        }\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/public/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/private/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TicalUniverseCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TicalUniverseCollection)\n            .borrow<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TicalUniverse.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xTicalUniverse": {
                "TicalUniverse": {
                  "testnet": {
                    "address": "0x58b60c5240d3f39b",
                    "contract": "TicalUniverse",
                    "fq_address": "A.0x58b60c5240d3f39b.TicalUniverse",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813348
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813351
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813356
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813357
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813357
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813362
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "22eb8729533402ed9df17d992a287884689eaa1657d117cd03223ae9c093dc30",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support TMNFTV2 NFTs"
                }
              }
            },
            "cadence": "import TMNFTV2 from 0xTMNFTV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TMNFTV2\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TMNFTV2.Collection>(from: /storage/TMNFTV2Collection) == nil {\n      let collection <- TMNFTV2.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TMNFTV2Collection)\n    }\n    if (signer.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection).borrow() == nil) {\n      signer.unlink(/public/TMNFTV2Collection)\n      signer.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xTMNFTV2": {
                "TMNFTV2": {
                  "testnet": {
                    "address": "0x87dc938d9246d780",
                    "contract": "TMNFTV2",
                    "fq_address": "A.0x87dc938d9246d780.TMNFTV2",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813874
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813878
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813882
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "1724d781df47567504e14efe2d30c18c4ac090fa88293c10f9f4bee5fe978e1b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed TMNFTV2 NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TMNFTV2 from 0xTMNFTV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TMNFTV2\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TMNFTV2.Collection>(from: /storage/TMNFTV2Collection) == nil {\n            let collection <- TMNFTV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TMNFTV2Collection)\n            }\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/public/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/private/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TMNFTV2Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xTMNFTV2": {
                "TMNFTV2": {
                  "testnet": {
                    "address": "0x87dc938d9246d780",
                    "contract": "TMNFTV2",
                    "fq_address": "A.0x87dc938d9246d780.TMNFTV2",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813916
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813920
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813925
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813926
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813926
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813931
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ecd33c1b6267d58643329716a528d99e10b6668b984b77867d16d8ce20221b42",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a TMNFTV2 NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import TMNFTV2 from 0xTMNFTV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TMNFTV2\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TMNFTV2.Collection>(from: /storage/TMNFTV2Collection) == nil {\n            let collection <- TMNFTV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TMNFTV2Collection)\n        }\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/public/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/private/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TMNFTV2Collection)!\n        let collectionRef = acct\n            .getCapability(/public/TMNFTV2Collection)\n            .borrow<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TMNFTV2.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xTMNFTV2": {
                "TMNFTV2": {
                  "testnet": {
                    "address": "0x87dc938d9246d780",
                    "contract": "TMNFTV2",
                    "fq_address": "A.0x87dc938d9246d780.TMNFTV2",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95813892
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813896
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813900
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95813902
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95813902
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813906
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7bcb598deb6ac80302544c5a7bc9fe2aeeec5f2854438e263affbc426c9161ba",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's collection to support a UFCStrike NFT"
                }
              }
            },
            "cadence": "import ufcInt_NFT from 0xufcInt_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: UFCStrike\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ufcInt_NFT.Collection>(from: /storage/ufcInt_NFTCollection) == nil {\n      let collection <- ufcInt_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ufcInt_NFTCollection)\n    }\n    if (signer.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/ufcInt_NFTCollection)\n      signer.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection, target: /storage/ufcInt_NFTCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95782192
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95782197
                  }
                }
              },
              "0xufcInt_NFT": {
                "ufcInt_NFT": {
                  "testnet": {
                    "address": "0x04625c28593d9408",
                    "contract": "ufcInt_NFT",
                    "fq_address": "A.0x04625c28593d9408.ufcInt_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95782208
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "635655ad42e7a9dc831752febb8400d3d17fd4fa79b5cac08a86a424209f7c3d",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed UFCStrike NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import ufcInt_NFT from 0xufcInt_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: UFCStrike\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ufcInt_NFT.Collection>(from: /storage/ufcInt_NFTCollection) == nil {\n            let collection <- ufcInt_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ufcInt_NFTCollection)\n            }\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/ufcInt_NFTCollection)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection, target: /storage/ufcInt_NFTCollection)\n        }\n\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT).borrow() == nil) {\n            acct.unlink(/private/ufcInt_NFT)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT, target: /storage/ufcInt_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ufcInt_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95812317
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95812322
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95812323
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95812324
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95812329
                  }
                }
              },
              "0xufcInt_NFT": {
                "ufcInt_NFT": {
                  "testnet": {
                    "address": "0x04625c28593d9408",
                    "contract": "ufcInt_NFT",
                    "fq_address": "A.0x04625c28593d9408.ufcInt_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95812339
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "b82d49985e7795664d2305c62bf4494366c2ae63c605429ea0a2c73f759e4d5e",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a UFCStrike NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import ufcInt_NFT from 0xufcInt_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: UFCStrike\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ufcInt_NFT.Collection>(from: /storage/ufcInt_NFTCollection) == nil {\n            let collection <- ufcInt_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ufcInt_NFTCollection)\n        }\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/ufcInt_NFTCollection)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection, target: /storage/ufcInt_NFTCollection)\n        }\n\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT).borrow() == nil) {\n            acct.unlink(/private/ufcInt_NFT)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT, target: /storage/ufcInt_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ufcInt_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/ufcInt_NFTCollection)\n            .borrow<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@ufcInt_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95812267
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95812272
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95812273
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95812274
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95812278
                  }
                }
              },
              "0xufcInt_NFT": {
                "ufcInt_NFT": {
                  "testnet": {
                    "address": "0x04625c28593d9408",
                    "contract": "ufcInt_NFT",
                    "fq_address": "A.0x04625c28593d9408.ufcInt_NFT",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95812287
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "212dff0efe8241c2eb0e2e1e883dbc0507f4fe2e83d4586fb1c947ae7d9a1301",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Wearables NFTs"
                }
              }
            },
            "cadence": "import Wearables from 0xWearables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Wearables\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Wearables.Collection>(from: /storage/wearables) == nil {\n      let collection <- Wearables.createEmptyCollection()\n      signer.save(<-collection, to: /storage/wearables)\n    }\n    if (signer.getCapability<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables).borrow() == nil) {\n      signer.unlink(/public/wearables)\n      signer.link<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables, target: /storage/wearables)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xWearables": {
                "Wearables": {
                  "mainnet": {
                    "address": "0xe81193c424cfd3fb",
                    "contract": "Wearables",
                    "fq_address": "A.0xe81193c424cfd3fb.Wearables",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47506569
                  },
                  "testnet": {
                    "address": "0x1e0493ee604e7598",
                    "contract": "Wearables",
                    "fq_address": "A.0x1e0493ee604e7598.Wearables",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95805342
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506586
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805349
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506593
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805359
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "9d6482979b33b4b1b524847d139dd9ce1d7dc61043aa4de2360f55bdddfc1120",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Wearables NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Wearables from 0xWearables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Wearables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Wearables.Collection>(from: /storage/wearables) == nil {\n            let collection <- Wearables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/wearables)\n            }\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables).borrow() == nil) {\n            acct.unlink(/public/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables, target: /storage/wearables)\n        }\n\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables).borrow() == nil) {\n            acct.unlink(/private/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables, target: /storage/wearables)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/wearables\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xWearables": {
                "Wearables": {
                  "mainnet": {
                    "address": "0xe81193c424cfd3fb",
                    "contract": "Wearables",
                    "fq_address": "A.0xe81193c424cfd3fb.Wearables",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47506662
                  },
                  "testnet": {
                    "address": "0x1e0493ee604e7598",
                    "contract": "Wearables",
                    "fq_address": "A.0x1e0493ee604e7598.Wearables",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95805457
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506679
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805464
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506686
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805474
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506690
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95805476
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506691
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805477
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506696
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805487
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "86c6e89af5d5faf7d28a4bee9a574e3b0732130567e54ffc172652741f6ee142",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Wearables NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import Wearables from 0xWearables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Wearables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Wearables.Collection>(from: /storage/wearables) == nil {\n            let collection <- Wearables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/wearables)\n        }\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables).borrow() == nil) {\n            acct.unlink(/public/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables, target: /storage/wearables)\n        }\n\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables).borrow() == nil) {\n            acct.unlink(/private/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables, target: /storage/wearables)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/wearables)!\n        let collectionRef = acct\n            .getCapability(/public/wearables)\n            .borrow<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Wearables.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xWearables": {
                "Wearables": {
                  "mainnet": {
                    "address": "0xe81193c424cfd3fb",
                    "contract": "Wearables",
                    "fq_address": "A.0xe81193c424cfd3fb.Wearables",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 47506611
                  },
                  "testnet": {
                    "address": "0x1e0493ee604e7598",
                    "contract": "Wearables",
                    "fq_address": "A.0x1e0493ee604e7598.Wearables",
                    "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
                    "pin_block_height": 95805393
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506626
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805400
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506632
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805410
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47506637
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95805412
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47506639
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95805414
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47506643
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95805423
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "7f6011babb67ee198ba4aac53e180a5cadfa1c8371fa7edd8e6bfff54fd61891",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support xG NFTs"
                }
              }
            },
            "cadence": "import XGStudio from 0xXGStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: xG\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&XGStudio.Collection>(from: /storage/XGStudioCollection) == nil {\n      let collection <- XGStudio.createEmptyCollection()\n      signer.save(<-collection, to: /storage/XGStudioCollection)\n    }\n    if (signer.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection).borrow() == nil) {\n      signer.unlink(/public/XGStudioCollection)\n      signer.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection, target: /storage/XGStudioCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xXGStudio": {
                "XGStudio": {
                  "mainnet": {
                    "address": "0xc357c8d061353f5f",
                    "contract": "XGStudio",
                    "fq_address": "A.0xc357c8d061353f5f.XGStudio",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47508914
                  },
                  "testnet": {
                    "address": "0xd9575c84a88eada0",
                    "contract": "XGStudio",
                    "fq_address": "A.0xd9575c84a88eada0.XGStudio",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95808120
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508927
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808127
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508935
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808136
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "be2e4d39898879ed5dd72ef7b4fb8f458714eab046fb7a88cc6ae77e04f3a18a",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed xG NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import XGStudio from 0xXGStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: xG\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XGStudio.Collection>(from: /storage/XGStudioCollection) == nil {\n            let collection <- XGStudio.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XGStudioCollection)\n            }\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection).borrow() == nil) {\n            acct.unlink(/public/XGStudioCollection)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection, target: /storage/XGStudioCollection)\n        }\n\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/XGStudioCollectionProvider)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider, target: /storage/XGStudioCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/XGStudioCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xXGStudio": {
                "XGStudio": {
                  "mainnet": {
                    "address": "0xc357c8d061353f5f",
                    "contract": "XGStudio",
                    "fq_address": "A.0xc357c8d061353f5f.XGStudio",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47508999
                  },
                  "testnet": {
                    "address": "0xd9575c84a88eada0",
                    "contract": "XGStudio",
                    "fq_address": "A.0xd9575c84a88eada0.XGStudio",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95808220
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509012
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808228
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509020
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808238
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47509023
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95808240
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47509024
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808241
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47509028
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808250
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "09d096d098eb596fd225ec2fd17c1d3c188e7ab8d26d7fd97c4e966b93663379",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a xG NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import XGStudio from 0xXGStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: xG\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XGStudio.Collection>(from: /storage/XGStudioCollection) == nil {\n            let collection <- XGStudio.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XGStudioCollection)\n        }\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection).borrow() == nil) {\n            acct.unlink(/public/XGStudioCollection)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection, target: /storage/XGStudioCollection)\n        }\n\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/XGStudioCollectionProvider)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider, target: /storage/XGStudioCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/XGStudioCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/XGStudioCollection)\n            .borrow<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@XGStudio.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xXGStudio": {
                "XGStudio": {
                  "mainnet": {
                    "address": "0xc357c8d061353f5f",
                    "contract": "XGStudio",
                    "fq_address": "A.0xc357c8d061353f5f.XGStudio",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 47508952
                  },
                  "testnet": {
                    "address": "0xd9575c84a88eada0",
                    "contract": "XGStudio",
                    "fq_address": "A.0xd9575c84a88eada0.XGStudio",
                    "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
                    "pin_block_height": 95808164
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508967
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808171
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508973
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808180
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47508978
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95808182
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47508979
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95808184
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47508985
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95808193
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "b059047838952bddd071093c0c2623e15df86b198a1415b2eba1fd8b232d8eb1",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support XvsXNFTCollection NFTs"
                }
              }
            },
            "cadence": "import XvsX from 0xXvsX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: XvsXNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&XvsX.Collection>(from: /storage/XvsXCollection) == nil {\n      let collection <- XvsX.createEmptyCollection()\n      signer.save(<-collection, to: /storage/XvsXCollection)\n    }\n    if (signer.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection).borrow() == nil) {\n      signer.unlink(/public/XvsXCollection)\n      signer.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection, target: /storage/XvsXCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xXvsX": {
                "XvsX": {
                  "mainnet": {
                    "address": "0xf2af175e411dfff8",
                    "contract": "XvsX",
                    "fq_address": "A.0xf2af175e411dfff8.XvsX",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510358
                  },
                  "testnet": {
                    "address": "0x26e7006d6734ba69",
                    "contract": "XvsX",
                    "fq_address": "A.0x26e7006d6734ba69.XvsX",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809815
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510368
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809822
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510374
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809832
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "fbbc6c28612285ef78aaaa79b997fd038e37e04b1b45fbfe4eee1b24870a3303",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed XvsXNFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import XvsX from 0xXvsX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: XvsXNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XvsX.Collection>(from: /storage/XvsXCollection) == nil {\n            let collection <- XvsX.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XvsXCollection)\n            }\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection).borrow() == nil) {\n            acct.unlink(/public/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection, target: /storage/XvsXCollection)\n        }\n\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection).borrow() == nil) {\n            acct.unlink(/private/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection, target: /storage/XvsXCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/XvsXCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xXvsX": {
                "XvsX": {
                  "mainnet": {
                    "address": "0xf2af175e411dfff8",
                    "contract": "XvsX",
                    "fq_address": "A.0xf2af175e411dfff8.XvsX",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510431
                  },
                  "testnet": {
                    "address": "0x26e7006d6734ba69",
                    "contract": "XvsX",
                    "fq_address": "A.0x26e7006d6734ba69.XvsX",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809902
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510442
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809909
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510449
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809919
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47510454
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809921
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510455
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809922
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510460
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809932
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "21d0281906b6a124bddd4d48d71e5a8ebd2fee4b2d7c0da4d6cfbeedc7e28cf9",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a XvsXNFTCollection NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import XvsX from 0xXvsX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: XvsXNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XvsX.Collection>(from: /storage/XvsXCollection) == nil {\n            let collection <- XvsX.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XvsXCollection)\n        }\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection).borrow() == nil) {\n            acct.unlink(/public/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection, target: /storage/XvsXCollection)\n        }\n\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection).borrow() == nil) {\n            acct.unlink(/private/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection, target: /storage/XvsXCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/XvsXCollection)!\n        let collectionRef = acct\n            .getCapability(/public/XvsXCollection)\n            .borrow<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@XvsX.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xXvsX": {
                "XvsX": {
                  "mainnet": {
                    "address": "0xf2af175e411dfff8",
                    "contract": "XvsX",
                    "fq_address": "A.0xf2af175e411dfff8.XvsX",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 47510388
                  },
                  "testnet": {
                    "address": "0x26e7006d6734ba69",
                    "contract": "XvsX",
                    "fq_address": "A.0x26e7006d6734ba69.XvsX",
                    "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                    "pin_block_height": 95809852
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510400
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809859
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510408
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809868
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47510413
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95809871
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47510413
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95809872
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47510419
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95809882
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "18af890564d0dcae2d5087da6a7f7fa454c5cc2990fdb2f7c610c6d52aca188c",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction initializes a user's account to support Zeedz NFTs"
                }
              }
            },
            "cadence": "import ZeedzINO from 0xZeedzINO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Zeedz\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ZeedzINO.Collection>(from: /storage/ZeedzINOCollection) == nil {\n      let collection <- ZeedzINO.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ZeedzINOCollection)\n    }\n    if (signer.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection).borrow() == nil) {\n      signer.unlink(/public/ZeedzINOCollection)\n      signer.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n    }\n  }\n\n}\n",
            "dependencies": {
              "0xZeedzINO": {
                "ZeedzINO": {
                  "mainnet": {
                    "address": "0x62b3063fbe672fc8",
                    "contract": "ZeedzINO",
                    "fq_address": "A.0x62b3063fbe672fc8.ZeedzINO",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47488159
                  },
                  "testnet": {
                    "address": "0x7dc7430a06f38af3",
                    "contract": "ZeedzINO",
                    "fq_address": "A.0x7dc7430a06f38af3.ZeedzINO",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95783483
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488170
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783490
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488177
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783501
                  }
                }
              }
            },
            "arguments": {}
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ceb2cf878357f959d431ff65ec865615c248a0234cc05ed8f8d0ddc8b02e5bf9",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the purchase of a listed Zeedz NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import ZeedzINO from 0xZeedzINO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Zeedz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ZeedzINO.Collection>(from: /storage/ZeedzINOCollection) == nil {\n            let collection <- ZeedzINO.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ZeedzINOCollection)\n            }\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/public/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/private/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ZeedzINOCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
            "dependencies": {
              "0xZeedzINO": {
                "ZeedzINO": {
                  "mainnet": {
                    "address": "0x62b3063fbe672fc8",
                    "contract": "ZeedzINO",
                    "fq_address": "A.0x62b3063fbe672fc8.ZeedzINO",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47488231
                  },
                  "testnet": {
                    "address": "0x7dc7430a06f38af3",
                    "contract": "ZeedzINO",
                    "fq_address": "A.0x7dc7430a06f38af3.ZeedzINO",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95783571
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488241
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783579
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488248
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783589
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47488253
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95783592
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488256
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783593
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488259
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783602
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              },
              "storefrontAddress": {
                "index": 1,
                "type": "Address",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "The address that owns the storefront listing"
                    }
                  }
                }
              },
              "commissionRecipient": {
                "index": 2,
                "type": "Address?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional recipient for transaction commission if comission exists"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "ceee11a51c6f212de060d33f01a5daf2e602cb4467d411a61a5f2b54e956fc9b",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "This transaction facilitates the listing of a Zeedz NFT with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import ZeedzINO from 0xZeedzINO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Zeedz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ZeedzINO.Collection>(from: /storage/ZeedzINOCollection) == nil {\n            let collection <- ZeedzINO.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ZeedzINOCollection)\n        }\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/public/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/private/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ZeedzINOCollection)!\n        let collectionRef = acct\n            .getCapability(/public/ZeedzINOCollection)\n            .borrow<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@ZeedzINO.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
            "dependencies": {
              "0xZeedzINO": {
                "ZeedzINO": {
                  "mainnet": {
                    "address": "0x62b3063fbe672fc8",
                    "contract": "ZeedzINO",
                    "fq_address": "A.0x62b3063fbe672fc8.ZeedzINO",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 47488188
                  },
                  "testnet": {
                    "address": "0x7dc7430a06f38af3",
                    "contract": "ZeedzINO",
                    "fq_address": "A.0x7dc7430a06f38af3.ZeedzINO",
                    "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
                    "pin_block_height": 95783520
                  }
                }
              },
              "0xNonFungibleToken": {
                "NonFungibleToken": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488199
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "NonFungibleToken",
                    "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783527
                  }
                }
              },
              "0xMetadataViews": {
                "MetadataViews": {
                  "mainnet": {
                    "address": "0x1d7e57aa55817448",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488205
                  },
                  "testnet": {
                    "address": "0x631e88ae7f1d7c20",
                    "contract": "MetadataViews",
                    "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783537
                  }
                }
              },
              "0xFlowToken": {
                "FlowToken": {
                  "mainnet": {
                    "address": "0x1654653399040a61",
                    "contract": "FlowToken",
                    "fq_address": "A.0x1654653399040a61.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 47488212
                  },
                  "testnet": {
                    "address": "0x7e60df042a9c0868",
                    "contract": "FlowToken",
                    "fq_address": "A.0x7e60df042a9c0868.FlowToken",
                    "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
                    "pin_block_height": 95783540
                  }
                }
              },
              "0xFungibleToken": {
                "FungibleToken": {
                  "mainnet": {
                    "address": "0xf233dcee88fe0abe",
                    "contract": "FungibleToken",
                    "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 47488213
                  },
                  "testnet": {
                    "address": "0x9a0766d93b6608b7",
                    "contract": "FungibleToken",
                    "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                    "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                    "pin_block_height": 95783542
                  }
                }
              },
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47488218
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95783551
                  }
                }
              }
            },
            "arguments": {
              "saleItemID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the NFT that is put on sale by the seller"
                    }
                  }
                }
              },
              "saleItemPrice": {
                "index": 1,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
                    }
                  }
                }
              },
              "customID": {
                "index": 2,
                "type": "String?",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Optional string to represent identifier of the dapp"
                    }
                  }
                }
              },
              "commissionAmount": {
                "index": 3,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Commission amount that will be taken away by the purchase facilitator"
                    }
                  }
                }
              },
              "expiry": {
                "index": 4,
                "type": "UFix64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Unix timestamp at which created listing become expired"
                    }
                  }
                }
              },
              "marketplacesAddress": {
                "index": 5,
                "type": "[Address]",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "List of addresses that are allowed to get the commission"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "0a803caf5e5e24d2a995eb51b588da44292c4bf65b1e77fecb5834111e6941af",
          "data": {
            "type": "transaction",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Remove NFT listing"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "This transaction facilitates the removal of an NFT listing with the StorefrontV2 contract"
                }
              }
            },
            "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
            "dependencies": {
              "0xNFTStorefrontV2": {
                "NFTStorefrontV2": {
                  "mainnet": {
                    "address": "0x4eb8a10cb9f87357",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 47513152
                  },
                  "testnet": {
                    "address": "0x2d55b98eb200daef",
                    "contract": "NFTStorefrontV2",
                    "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
                    "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                    "pin_block_height": 95813107
                  }
                }
              }
            },
            "arguments": {
              "listingResourceID": {
                "index": 0,
                "type": "UInt64",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "ID of the Storefront listing resource"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "json": {
          "f_type": "InteractionTemplate",
          "f_version": "1.0.0",
          "id": "bd10ab0bf472e6b58ecc0398e9b3d1bd58a4205f14a7099c52c0640d9589295f",
          "data": {
            "type": "script",
            "interface": "",
            "messages": {
              "title": {
                "i18n": {
                  "en-US": "Multiply Two Integers"
                }
              },
              "description": {
                "i18n": {
                  "en-US": "Multiplies two integer arguments together and returns the result."
                }
              }
            },
            "cadence": "pub fun main(x: Int, y: Int): Int { return x * y }",
            "dependencies": {},
            "arguments": {
              "x": {
                "index": 0,
                "type": "Int",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Int 1"
                    }
                  }
                }
              },
              "y": {
                "index": 1,
                "type": "Int",
                "messages": {
                  "title": {
                    "i18n": {
                      "en-US": "Int 2"
                    }
                  }
                }
              }
            }
          }
        }
      }
    ]
  },
  "connections": {
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Workflow Input Trigger": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a0f51d60-a0d3-41b4-8059-dc119e1a8d5e",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "9a127041ab2c0a456c612db2c737ce582ec8f8dd14205bcdca991d2585b3c019"
  },
  "id": "ZrEhiHMPnYwUTS4T",
  "tags": []
}